#VRML V2.0 utf8

EXTERNPROTO Bitmap [
	exposedField SFVec2f scale
	exposedField SFBool pixelMetric
]
["urn:inet:bitmanagement.de:node:Bitmap"]

EXTERNPROTO FGeometry [
	exposedField SFString definition
	exposedField MFFloat parameters
	exposedField MFInt32 resolution
	exposedField SFVec3f bboxCenter
	exposedField SFVec3f bboxSize
	exposedField SFString type
	exposedField MFNode	parents
	exposedField SFVec2f timeSpan
] "FVRML.wrl#FGeometry"

EXTERNPROTO FMaterial [
	exposedField SFString diffuseColor
	exposedField SFString type
	exposedField MFColor patternColor
	exposedField MFFloat patternKey
	exposedField SFString ambientIntensity
	exposedField SFString emissiveColor
	exposedField SFString shininess
	exposedField SFString specularColor
	exposedField SFString transparency
	exposedField MFNode	parents
	exposedField SFVec2f timeSpan
] "FVRML.wrl#FMaterial"
#------------------------------------------------------------------
EXTERNPROTO	FPhysics
[
	exposedField SFNode	surface

	exposedField SFNode	density

	exposedField SFNode	forcefield
] "FVRML.wrl#FPhysics"
#------------------------------------------------------------------
EXTERNPROTO	FSurface
[
	exposedField SFNode	friction

	exposedField SFNode	tension
] "FVRML.wrl#FSurface"
#------------------------------------------------------------------
EXTERNPROTO	FFriction
[
	exposedField SFBool	enable
	exposedField SFString definition
	exposedField SFVec3f bboxCenter 
	exposedField SFVec3f bboxSize
	exposedField SFVec3f bboxCenter2 
	exposedField SFVec3f bboxSize2
	exposedField SFVec2f timeSpan
	exposedField SFTime cycleInterval
	exposedField SFBool	loop
] "FVRML.wrl#FFriction"
#------------------------------------------------------------------
EXTERNPROTO	FTension
[
	exposedField SFBool	enable
	exposedField SFString definition
	exposedField SFVec3f bboxCenter 
	exposedField SFVec3f bboxSize
	exposedField SFVec3f bboxCenter2 
	exposedField SFVec3f bboxSize2
	exposedField SFVec2f timeSpan
	exposedField SFTime cycleInterval
	exposedField SFBool	loop
] "FVRML.wrl#FTension"
#------------------------------------------------------------------
EXTERNPROTO	FDensity 
[
	exposedField SFBool	 enable
	exposedField SFString definition 
	exposedField SFVec3f bboxCenter 
	exposedField SFVec3f bboxSize
	exposedField SFVec3f bboxCenter2 
	exposedField SFVec3f bboxSize2
	exposedField SFVec2f timeSpan
	exposedField SFTime cycleInterval
	exposedField SFBool	loop
] "FVRML.wrl#FDensity"
#------------------------------------------------------------------
EXTERNPROTO	FForce 
[
	exposedField SFBool	enable
	exposedField SFString definition 
	exposedField MFFloat parameters
    exposedField MFFloat parameters2
	exposedField SFVec2f timeSpan
	exposedField SFTime cycleInterval
	exposedField SFBool	loop
] "FVRML.wrl#FForce"
#------------------------------------------------------------------
EXTERNPROTO FTexture3D [
	exposedField SFString definition
	exposedField SFString type
	exposedField MFFloat parameters
	exposedField MFNode	parents
	exposedField SFVec2f timeSpan
] "FVRML.wrl#FTexture3D"

EXTERNPROTO FAppearance [
	exposedField SFNode	material
	exposedField SFNode	texture
	exposedField SFNode	textureTransform
	exposedField SFNode	texture3D
	exposedField MFNode	parents
	eventIn	SFBool refresh
] "FVRML.wrl#FAppearance"



EXTERNPROTO FShape [
	exposedField SFNode	geometry
	exposedField SFNode	appearance

	exposedField SFNode	physics
	exposedField SFString collision


	exposedField SFString polygonizer
	exposedField MFNode	parents
	exposedField SFTime	startTime
	exposedField SFTime stopTime
    exposedField SFTime cycleInterval
    exposedField SFBool	loop
	exposedField SFBool	enabled
	eventOut SFTime	cycleTime
	eventIn SFFloat set_fraction
	field SFInt32 frames
] "FVRML.wrl#FShape"

EXTERNPROTO FTransform [
	exposedField SFString operation
	exposedField SFString type
	exposedField SFString polygonizer
	exposedField MFFloat parameters
	exposedField SFString center
	exposedField SFString rotation
	exposedField SFString scale
	exposedField SFString scaleOrientation
	exposedField SFString translation
	exposedField MFNode children
	exposedField MFNode	parents
	eventIn	SFBool refresh
    exposedField SFVec2f timeSpan
	exposedField SFTime	startTime
	exposedField SFTime stopTime
    exposedField SFTime cycleInterval
    exposedField SFBool	loop
	exposedField SFBool	enabled
	eventOut SFTime	cycleTime
	eventIn SFFloat set_fraction

	field SFInt32 frames
] "FVRML.wrl#FTransform"

EXTERNPROTO KeySensor [
  eventIn      SFBool     eventsProcessed 
  exposedField SFBool     enabled
  eventOut     SFInt32    keyPress 
  eventOut     SFInt32    keyRelease 
  eventOut     SFInt32    actionKeyPress 
  eventOut     SFInt32    actionKeyRelease 
  eventOut     SFBool     shiftKey_changed 
  eventOut     SFBool     controlKey_changed 
  eventOut     SFBool     altKey_changed 
  eventOut     SFBool     isActive 
]["urn:inet:bitmanagement.de:node:KeySensor",
"http://www.bitmanagement.de/vrml/protos/nodes.wrl#KeySensor"]



EXTERNPROTO Layer3D [
	exposedField SFVec3f bboxSize
	exposedField SFVec3f bboxCenter
	eventIn MFNode addChildrenLayer
	eventIn MFNode removeChildrenLayer
	exposedField MFNode childrenLayer
	exposedField SFVec2f translation
	exposedField SFInt32 depth
	exposedField SFVec2f size
	exposedField SFNode background
#	exposedField SFNode fog
#	exposedField SFNode navigationInfo
	exposedField SFNode viewpoint
	exposedField MFNode children
	eventIn MFNode addChildren
	eventIn MFNode removeChildren
] ["urn:inet:bitmanagement.de:node:Layer3D","http://www.bitmanagement.de/vrml/protos/nodes.wrl#Layer3D"]


EXTERNPROTO MouseSensor[ 
        eventIn      SFBool      eventsProcessed 
        exposedField SFBool      enabled 
        eventOut     SFVec2f     client 
        eventOut     SFVec2f     position 
        eventOut     SFBool      lButton 
        eventOut     SFBool      mButton 
        eventOut     SFBool      rButton 
        eventOut     SFFloat     mouseWheel 
        eventOut     SFBool      isActive  
        ] 
["urn:inet:blaxxun.com:node:MouseSensor",
"http://www.blaxxun.com/vrml/protos/nodes.wrl#MouseSensor",
]

DEF ms MouseSensor{}

EXTERNPROTO	TouchSensor2[
	exposedField SFBool	enabled
	eventOut SFVec3f hitNormal
	eventOut SFVec3f hitPoint
	eventOut SFVec2f hitTexCoord
	eventOut SFBool	isActive
	eventOut SFBool	isOver
	eventOut SFTime	touchTime
	eventOut SFTime	doubleClickTime
	exposedField SFBool	want2ndTouchTime
	exposedField SFString description
	exposedField SFNode	metadata
]
["urn:inet:bitmanagement.de:node:TouchSensor2",
	"http://www.bitmanagement.de/vrml/protos/nodes.wrl#TouchSensor2"
]

EXTERNPROTO	MetadataString[
	exposedField SFNode	metadata
	exposedField SFString name
	exposedField SFString reference
	exposedField MFString value
]
["urn:inet:bitmanagement.de:node:MetadataString","http://www.bitmanagement.de/vrml/protos/nodes.wrl#MetadataString","nodes.wrl#MetadataString"]

NavigationInfo {
	type ["EXAMINE","ANY"]

}

Viewpoint {
fieldOfView 0.7
position 0 0 10
description "Overview"
}
Background {skyColor 0 0 0.25}
PROTO BlaxxunZone [ 
exposedField    MFNode   events []
exposedField    MFString groupChat ""
]
{
}

#--------------------
#--------------------
#-----FMShape is designed for define the transformation of geometry and appearance separetely.
#--	 PROTO FMShape---
PROTO FMShape [
	exposedField SFNode	geometry NULL
	exposedField SFRotation grotation 0 0 1 0
	exposedField SFVec3f gscale	  1 1 1
	exposedField SFVec3f gtranslation 0 0 0

	exposedField SFNode	appearance NULL
	exposedField SFRotation arotation 0 0 1 0
	exposedField SFVec3f ascale	  1 1 1
	exposedField SFVec3f atranslation 0 0 0

	exposedField SFInt32 coorgeometry 0	  #for flag whether show coordinates of geometry
	exposedField SFInt32 coorappearance 0 #for flag whether show coordinates of appearance
	exposedField SFInt32 boxgeometry 1	 #for flag whether show box of geometry
	exposedField SFInt32 boxappearance 1 #for flag whether show box of appearance

	exposedField SFString geoDef ""	  #geometry definition
	exposedField SFString difusecolorDef ""	   # difusecolor definition

#	exposedField SFNode	physics NULL

	exposedField SFString polygonizer "analytical"

	exposedField SFString collision "polygonal"

	exposedField MFNode	parents []
	eventIn SFBool refresh
	#time-dependent
	exposedField SFTime	startTime 0
	exposedField SFTime stopTime 0
    exposedField SFTime cycleInterval 1
    exposedField SFBool	loop FALSE
	exposedField SFBool	enabled TRUE
	eventOut SFTime	cycleTime
	#Used for external TimeSensor
	eventIn SFFloat set_fraction
	#Cache frames
	#0 means no cache
	field SFInt32 frames 0
] {
DEF GG Group {
	children [
		DEF gtransform Transform {
			translation IS	gtranslation
			rotation IS	grotation
			scale IS gscale
			children[    
				FShape {
		appearance FAppearance {
		material FMaterial {
			transparency "1"
		diffuseColor "r=0.7;g=0.7;b=0.7; "
		}
	}
	geometry IS geometry
}

Switch {
	choice [
	Inline { url "CoordinateAxes.wrl"}
]
whichChoice	IS coorgeometry

}

Switch {
	choice [
			Shape {
			geometry IndexedLineSet {
			color Color	{
#				color [0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7]}
				color [1 1 1,1 1 1,1 1 1,1 1 1,1 1 1,1 1 1,1 1 1,1 1 1]}
							coord Coordinate {
								point [
									-2.00 -2.00 -2.00, 
									-2.00 -2.00 2.00,
									-2.00 2.00 -2.00,
								    -2.00 2.00 2.00,
									2.00 -2.00 -2.00, 
									2.00 -2.00 2.00,
									2.00 2.00 -2.00,
								    2.00 2.00 2.00
								]
							}
							coordIndex [
								0,1,-1,0,4,-1,1,5,-1,4,5,-1,
								2,3,-1,3,7,-1,7,6,-1,6,2,-1,
								3,1,-1,7,5,-1,6,4,-1,2,0,-1
 							]
						}
	}
]
whichChoice	IS boxgeometry

}

]}
	
DEF atransform Transform {
					translation IS	atranslation
					rotation IS	arotation
					scale IS ascale
					children[  FShape {
					appearance IS appearance
					geometry FGeometry {
					
					}
						geometry FGeometry{
						resolution [200 200]
						parameters [-1 1 -1 1]
						definition "(x+2)&(2-x)&(y+2)&(2-y)&(z+2)&(2-z)"
					}
				}

Switch {
	choice [
	Inline { url "CoordinateAxesRed.wrl"}
]
whichChoice	IS coorappearance

}

Switch {
	choice [
		Shape {
			geometry IndexedLineSet {
			color Color	{
#				color [0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7,0.7 0.7 0.7]}
				color [1 1 1,1 1 1,1 1 1,1 1 1,1 1 1,1 1 1,1 1 1,1 1 1]}
							coord Coordinate {
								point [
									-2.00 -2.00 -2.00, 
									-2.00 -2.00 2.00,
									-2.00 2.00 -2.00,
								    -2.00 2.00 2.00,
									2.00 -2.00 -2.00, 
									2.00 -2.00 2.00,
									2.00 2.00 -2.00,
								    2.00 2.00 2.00
								]
							}
							coordIndex [
								0,1,-1,0,4,-1,1,5,-1,4,5,-1,
								2,3,-1,3,7,-1,7,6,-1,6,2,-1,
								3,1,-1,7,5,-1,6,4,-1,2,0,-1
 							]
						}
	}
]
whichChoice	IS boxappearance

}



]
}
]}
	DEF	Run Script {
		directOutput TRUE
		mustEvaluate TRUE
#		url	"object:clsid={AA77BEEF-38BC-48A2-B053-6C8DF3C604D8}"
		exposedField MFNode parents IS parents
		eventIn	SFBool refresh IS refresh
		exposedField SFNode geometry IS geometry
		exposedField SFNode appearance IS appearance

		exposedField SFRotation grotation IS grotation
		exposedField SFVec3f gscale IS	gscale
		exposedField SFVec3f gtranslation IS gtranslation

		exposedField SFRotation arotation IS	arotation
		exposedField SFVec3f ascale IS	ascale
		exposedField SFVec3f atranslation IS atranslation

		exposedField SFString geoDef IS	geoDef
		exposedField SFString difusecolorDef IS difusecolorDef

#		exposedField SFNode physics IS physics

		exposedField SFString polygonizer IS polygonizer
		eventOut SFString console
		eventOut MFNode	shapes
		eventIn SFFloat set_fraction IS set_fraction

		eventIn	SFTime time

		field SFInt32 frames IS frames
	}


	DEF	Time TimeSensor	{
		enabled	IS enabled
		loop IS	loop
		startTime IS startTime
		cycleInterval IS cycleInterval
		cycleTime IS cycleTime
		stopTime IS	stopTime
	}

	DEF	Getter TimeSensor {
		enabled	TRUE
		loop TRUE
	}

    DEF Console Script {
		eventIn	SFString str
		url	"javascript: function str(v) {print(v);}"
	}

	ROUTE Run.console TO Console.str
	ROUTE Run.shapes TO	GG.children
	ROUTE Time.fraction_changed	TO Run.set_fraction
	ROUTE Getter.time TO Run.time
}

#!---------------------------------
#!---------------------------------


PROTO SharedEvent [ 
exposedField SFString    name "event" 
eventIn   SFString  stringFromServer 
eventOut  SFString  stringToServer 
eventIn   SFString  set_string 
eventOut  SFString  string_changed
eventOut  SFBool    initialized 
]
{
Script {
eventIn   SFString  stringFromServer    IS   stringFromServer
eventOut  SFString  stringToServer      IS   stringToServer
eventIn   SFString  set_string     IS   set_string
eventOut  SFString  string_changed      IS   string_changed
eventOut  SFBool    initialized    IS   initialized
url "vrmlscript:
function initialize( time ) { initialized = TRUE;}
//function stringFromServer (value, time) { string_changed = value; }
function set_string (value, time) { string_changed = value; }
"
}
}

DEF SharedZone BlaxxunZone {
	events [
		DEF	Lock SharedEvent {
			name "P_S_LOCK_Shape_Edit"
		}
		DEF	ShapeMsg SharedEvent {
			name "Messages"
		}
		DEF	Init SharedEvent {
			name "P_S_PILOT_Init_Responsor"
		}
		DEF	MsgLock SharedEvent	{
			name "P_S_LOCK_Message"
		}
	]
}

PROTO SimpleTouchSensor2[
	exposedField SFBool	enabled	TRUE
	eventOut SFVec3f hitNormal
	eventOut SFVec3f hitPoint
	eventOut SFVec2f hitTexCoord
	eventOut SFBool	isActive
	eventOut SFBool	isOver
	eventOut SFTime	touchTime
	eventOut SFTime	doubleClickTime
	exposedField SFBool	want2ndTouchTime FALSE
	exposedField SFString description ""

	eventOut SFString TouchID
	field SFInt32 IDHead 0
]{
	DEF	Sensor TouchSensor2	{
		enabled	IS enabled
		hitNormal IS hitNormal
		hitPoint IS	hitPoint
		hitTexCoord	IS hitTexCoord
		isActive IS	isActive
		isOver IS isOver
		touchTime IS touchTime
		doubleClickTime	IS doubleClickTime
		want2ndTouchTime IS	want2ndTouchTime
		description	IS description
	}
	DEF MetaString MetadataString	{
		#name IS	description
		reference IS TouchID
	}

	DEF Run Script {
		url	"javascript:
		function initialize()
		{
		  countClick=0;
		  countDoubleClick = 0;
		}
		function Click()
		{ 
		//	if (!isOver) nowColor = color;
			TouchID = countClick+'s'+description;
			if(countClick==9){countClick=0;}
			else countClick++;
		}
		function DoubleClick()
		{
			TouchID = countDoubleClick+'d'+description;
			if(countDoubleClick==9){countDoubleClick=0;}
			else countDoubleClick++;
		}
		
		"
		eventIn	SFTime Click
		eventIn	SFTime DoubleClick
		#eventIn	SFString Name
		eventOut SFString TouchID
		exposedField SFString description IS description

		field SFInt32 countClick 0
		field SFInt32 countDoubleClick 0
	
		
	}
	ROUTE Sensor.doubleClickTime TO	Run.DoubleClick
	ROUTE Sensor.touchTime TO Run.Click

	ROUTE Run.TouchID TO MetaString.reference
#	ROUTE MetaString.name TO Run.Name



}


PROTO HandleTool[

	eventIn	SFString toolname
	eventIn	SFString tooldefinition		 #geometry function definition
	eventIn	SFString tooldiffusecolor	 #3D color function definition
	eventIn	SFString tooltransparency	 #transparency

	eventIn	SFVec3f	tooltransformTrans
	eventIn	SFRotation tooltransformRot

	eventIn SFVec3f toollocaltransformScale
	eventIn SFVec3f toollocaltransformTrans
	eventIn	SFRotation toollocalrotationtransformRot

	eventIn SFRotation toolrolltransformRot
	eventIn SFRotation toolpitchtransformRot
	eventIn SFRotation toolyawtransformRot
	



	eventIn	SFBool refresh
	eventIn	SFInt32 dele
	eventIn	SFInt32 undoDele

	eventIn	SFInt32	focus
	eventIn SFInt32	undofocus
	
	eventIn	SFInt32	showSwitch # 0 show 1 hide

	exposedField SFString name ""
	exposedField SFString definition ""
	exposedField SFString diffusecolor "r=0.7;g=0.7;b=0.7;"
	exposedField SFString materTransparency "0.5"
	exposedField SFVec3f	transformTrans 0 0 0
	exposedField SFRotation transformRot 0 0 1 0
	exposedField SFVec3f localtransformScale 1 1 1 
	exposedField SFVec3f localtransformTrans 0 0 0
	exposedField SFRotation rolltransformRot 0 0 1 0
	exposedField SFRotation pitchtransformRot 1 0 0 0
	exposedField SFRotation yawtransformRot 0 1 0 0
	
	exposedField SFRotation	localrotationtransformRot 0 0 1 0
	

	eventOut SFString TouchID


	#field SFInt32 IDHead 0
]{
	
DEF name Transform {
		children [
			DEF TouchSensor2Name SimpleTouchSensor2 {description "" }
			DEF	showSwitch Switch {
				choice [
			DEF	HG Group {}
		]
		whichChoice	0
		}
]

}

DEF MetaString MetadataString	{
		#name IS	description
		reference IS TouchID
	}


	DEF Run Script {
		field SFString savecolor "r=0.7;g=0.7;b=0.7"

		url	"javascript:
		function initialize()
		{
		refresh();
		toolnameout = ftoolname;
		showS = 0;
				 
		}

		function TouchSensorIn(t){
			TouchID = t;
		}

		function name(t){
			ftoolname = t;
			toolnameout = t;
		}

		function definition(t){
			ftooldefinition = t;
		
		}

   		function diffusecolor(t){
			ftooldiffusecolor = t;
		}

		function mattransparency(t){
			ftoolransparency = t;
		}
		function transformTrans(t){
			ftooltransformTrans = t;
		}

		function transformRot(t){
			ftooltransformRot = t;
		}
		function localtransformScale(t){
			ftoollocaltransformScale = t;
		}

		function localtransformTrans(t){
			ftoollocaltransformTrans = t;
		}

		function rolltransformRot(t){
			ftoolrolltransformRot = t;
		}

		function pitchtransformRot(t){
			ftoolpitchtransformRot = t;
		}

		function yawtransformRot(t){
			ftoolyawtransformRot = t;
		}

		function localrotationtransformRot(t){
			ftoollocalrotationtransformRot = t;
		}

		function dele(t){
			tempnode = emptynode;
		}

		function focus(t){
			ftoolransparency = 0;
			//savecolor =  ftooldiffusecolor;
			//ftooldiffusecolor = 'r=1;g=0;b=0;';

			refresh();

		}

		function undofocus(t){

			ftoolransparency = 0.5;
			//ftooldiffusecolor = savecolor;
			//ftooldiffusecolor = 'r=0.7;g=0.7;b=0.7;';
			refresh();

		}

		function undoDele(t){
			tempnode = Browser.createVrmlFromString(str2);
		}

		function showSwitch(t){
			showS = t;
		}
		
		function refresh(){
			
 			var strHandle = '';
			strHandle+='  Transform	{\n';
			strHandle+='translation '+ ftooltransformTrans+'\n';
			strHandle+='rotation '+ ftooltransformRot+'\n';
			strHandle+='children [\n';
			strHandle+=' Transform {\n';
			strHandle+='rotation '+ ftoolrolltransformRot+'\n';
			strHandle+='children [\n';
			strHandle+=' Transform {\n';
			strHandle+='rotation '+ ftoolpitchtransformRot+'\n';
			strHandle+='children [\n';
			strHandle+=' Transform	{\n';
			strHandle+='rotation '+ ftoolyawtransformRot+'\n';
			strHandle+='children [\n';
			strHandle+=' Transform	{\n';
			strHandle+='rotation '+ ftoollocalrotationtransformRot+'\n';
			strHandle+='children [\n';
			strHandle+=' Transform {';
			strHandle+='translation '+ ftoollocaltransformTrans+'\n';
			strHandle+='scale '+ ftoollocaltransformScale +'\n';
			strHandle+='children [\n';
			strHandle+='SphereSensor {enabled	FALSE}\n';
			strHandle+='PlaneSensor {enabled	FALSE}\n';
			strHandle+=' PlaneSensor {enabled	FALSE}\n';
			strHandle+=' PlaneSensor {enabled	FALSE}\n';
			strHandle+=' Transform{\n';
			strHandle+='rotation 1 0 0 -1.5707963\n';
			strHandle+='children [\n';
			strHandle+=' CylinderSensor {enabled	FALSE}\n';
			strHandle+=' Transform{\n';
			strHandle+='rotation 1 0 0 1.5707963\n';
			strHandle+='children [\n';
			strHandle+=' CylinderSensor {enabled	FALSE}\n';
			strHandle+=' Transform{\n';
			strHandle+='rotation 0 0 1 -1.5707963\n';
			strHandle+='children [\n';
			strHandle+=' CylinderSensor {enabled	FALSE}\n';
			strHandle+=' Transform{\n';
			strHandle+='rotation 0 0 1 1.5707963\n';
			strHandle+='children [\n';
			strHandle+=' FShape{\n';
			strHandle+='appearance FAppearance {\n';
			strHandle+='material  FMaterial {\n';
			strHandle+='diffuseColor \"'+ftooldiffusecolor+'\"\n';
			strHandle+='transparency \"'+ftoolransparency+'\"\n';
			strHandle+='}}\n';
			strHandle+='geometry  FGeometry	{\n';
			strHandle+='type \"analytical\"\n';
			strHandle+='definition \"'+ftooldefinition+'\"\n';
			strHandle+='bboxCenter 0 0 0\n';
			strHandle+='bboxSize 2.5 2.5 2.5\n';
			strHandle+='resolution [100 100 100]\n';
			strHandle+='}}]}]}\n';
			strHandle+=']}]}]}\n';
			strHandle+=']}]}]}]}]}\n';

		
			if(strHandle!=str2){
			tempnode = Browser.createVrmlFromString(strHandle);
			str2 = strHandle;


		}
	}
				
		"
	
		eventIn	SFString TouchSensorIn
 		eventIn	SFString name IS toolname
		eventIn	SFString definition IS tooldefinition
		eventIn	SFString diffusecolor IS tooldiffusecolor
		eventIn	SFString mattransparency IS	tooltransparency
		eventIn	SFVec3f	transformTrans IS tooltransformTrans
		eventIn	SFRotation transformRot IS tooltransformRot
		eventIn	SFVec3f	localtransformScale IS toollocaltransformScale
		eventIn	SFVec3f	localtransformTrans IS toollocaltransformTrans
		eventIn	SFRotation rolltransformRot IS toolrolltransformRot
		eventIn	SFRotation pitchtransformRot IS	toolpitchtransformRot
		eventIn	SFRotation yawtransformRot IS toolyawtransformRot
		
		eventIn	SFRotation localrotationtransformRot IS	toollocalrotationtransformRot

		eventIn	SFBool refresh IS refresh
		eventIn	SFInt32 dele IS dele

		eventIn	SFInt32	focus IS focus
		eventIn SFInt32	undofocus IS undofocus

		eventIn	SFInt32	undoDele IS	undoDele

		

		eventIn	SFInt32 showSwitch IS  showSwitch

		
		exposedField SFString ftoolname IS name
		exposedField SFString ftooldefinition IS definition
		exposedField SFString ftooldiffusecolor IS diffusecolor
		exposedField SFString ftoolransparency IS materTransparency
		exposedField SFVec3f	ftooltransformTrans IS transformTrans
		exposedField SFRotation ftooltransformRot IS	transformRot
		exposedField SFVec3f ftoollocaltransformScale IS	localtransformScale
		exposedField SFVec3f ftoollocaltransformTrans IS	localtransformTrans
		exposedField SFRotation ftoolrolltransformRot IS	rolltransformRot
		exposedField SFRotation ftoolpitchtransformRot IS pitchtransformRot
		exposedField SFRotation ftoolyawtransformRot	IS yawtransformRot

		exposedField SFRotation	ftoollocalrotationtransformRot IS localrotationtransformRot

		eventOut SFInt32 showS

		eventOut MFNode tempnode   

		eventOut SFString toolnameout
		eventOut SFString TouchID

		eventIn	SFTime time
		field SFString str2 ""
		field MFNode emptynode []
	
		
	}

	  ROUTE	Run.toolnameout TO	TouchSensor2Name.description
	  ROUTE	TouchSensor2Name.TouchID TO	Run.TouchSensorIn
	  ROUTE	Run.TouchID	TO MetaString.reference 
	  ROUTE	Run.tempnode TO HG.children	

	  ROUTE	Run.showS TO showSwitch.whichChoice

}



#******************************************************************
#
# Tool definition starts here
#
#******************************************************************

######### used for click show the tool for modeling

DEF ShowHideTool Switch {
	choice [
		DEF	ToolTransform Transform {
			children [
				DEF	ToolRollTransform Transform {
					rotation 0 0 1 0
					children [
				DEF	ToolPitchTransform Transform {
					rotation 1 0 0 0
					children [
				DEF	ToolYawTransform Transform	{
					rotation 0 1 0 0
					children [
				DEF	ToolLocalRotationTransform Transform	{
					children [
				DEF ToolLocalTransform Transform {
					children [
						DEF ToolRotationSensor SphereSensor {
							enabled	TRUE
						}
						DEF	ToolDisplacementSensor PlaneSensor {
							enabled	FALSE
						}
						DEF	ToolScaleSensor PlaneSensor {
							enabled	FALSE
						}
						DEF	ToolMoveSensor PlaneSensor {
							enabled	FALSE
						}
						#RollSensor begin
						Transform {
							rotation 1 0 0 -1.5707963
							children [
								DEF	ToolRollSensor CylinderSensor {
									enabled	FALSE
								}
								Transform {
									rotation 1 0 0 1.5707963
									children [
										DEF	ToolYawSensor CylinderSensor {
											enabled	FALSE
										}
						#PitchSensor begin
						Transform {
							rotation 0 0 1 -1.5707963
							children [
								DEF	ToolPitchSensor CylinderSensor {
									enabled	FALSE
								}
								Transform {
									rotation 0 0 1 1.5707963
									children [
						FShape {
							appearance FAppearance {
								material DEF ToolMaterial FMaterial {
									diffuseColor "r=0.7;g=0.7;b=0.7;"
									transparency "0"
								}
							}
							geometry DEF ToolGeometry FGeometry	{
								type "analytical"
								definition "0.1-sqrt(x*x+y*y+z*z)"
								bboxCenter 0 0 0
								bboxSize 2.5 2.5 2.5
								resolution [100 100 100]
							}

									}

					#####################coord

						Group {
  children [
    # Vertical Y arrow and label
	  Transform	{
		  scale 0.3 0.3 0.3
		  children [
	  DEF ARROW Group {
      children [
	Shape {
		appearance DEF ARROW_APPEARANCE Appearance {
	    material Material {
	     # diffuseColor .3 .3 1
			diffuseColor .7 .7 .7
	      emissiveColor .1 .1 .33
	    }
	  }
	  geometry Cylinder {
		 bottom TRUE
	    radius .02
	    top TRUE
	  }
	}
	Transform {
		translation 0 1 0
	  children [
	    DEF ARROW_POINTER Shape {
	      geometry Cone {
		bottomRadius .04
		height .1
	      }
	      appearance USE ARROW_APPEARANCE
	    }
	  ]
	}
	Transform {
	  rotation 1 0 0 3.1416
	  translation 0 -1 0
	  children [
#	    USE ARROW_POINTER
	  ]
	}
      ]
    }
 ]}
  ]
}
Transform {
      translation 0 0.3 0
	  scale 0.3 0.3 0.3
      children [
	Billboard {
	  children [
	    Shape {
	      appearance DEF LABEL_APPEARANCE Appearance {
		material Material {
		  diffuseColor 1 0 0
		  emissiveColor 0 0 0
		}
	      }
	      geometry Text {
		string [ "Y" ]
		fontStyle DEF LABEL_FONT FontStyle {
		  family [ "SANS" ]
		  justify [ "MIDDLE" ]
		  size .35
		}
	      }
	    }
	  ]
	}
      ]
    }
Transform {
  scale 0.3 0.3 0.3
  rotation 0 0 1 -1.5708
  children [
    # Horizontal X arrow and label
    Group {
      children [
	USE ARROW
	Transform {
	  rotation 0 0 1 1.5708
	  translation .072 1.1 0
	  children [
	    # note label rotated back to original coordinate frame
	    Billboard {
	      children [
		Shape {
		  appearance USE LABEL_APPEARANCE
		  geometry Text {
		    string [ "X" ]
		    fontStyle USE LABEL_FONT
		  }
		}
	      ]
	    }
	  ]
	}
      ]
    }
  ]
}
Transform {
  scale 0.3 0.3 0.3
  rotation 1 0 0 1.5708
  children [
    # Perpendicular Z arrow and label, note right-hand rule
    Group {
      children [
	USE ARROW
	Transform {
	  rotation 1 0 0 -1.5708
	  translation 0 1.1 .072
	  children [
	    # note label rotated back to original coordinate frame
	    Billboard {
	      children [
		Shape {
		  appearance USE LABEL_APPEARANCE
		  geometry Text {
		    string [ "Z" ]
		    fontStyle USE LABEL_FONT
		  }
		}
	      ]
	    }
	  ]
	}
      ]
    }
  ]
}

###################coord

								
					#PitchSensor end
					]}]}
					#RollSensor end
					]}]}
					]
				}
			]}]}]}]}
			]
		}
	]
	whichChoice	1
}


#################################### delete on 28/09/2011################no use?

# Switch {
#	choice [
#		DEF	toolTransform Transform {
#			children [
#				DEF	toolRollTransform Transform {
#					children [
#				DEF	toolPitchTransform Transform {
#					children [
#				DEF	toolYawTransform Transform	{
#					children [
#				DEF	toolLocalRotationTransform Transform	{
#					children [					
#				DEF toolLocalTransform Transform {
#					children [
#						Transform {
#							rotation 1 0 0 -1.5707963
#							children [
#								DEF	toolRollSensor CylinderSensor {
#									enabled	FALSE
#								}
#								Transform {
#									rotation 1 0 0 1.5707963
#									children [
#										DEF	toolYawSensor CylinderSensor {
#											enabled	FALSE
#										}
#						Transform {
#							rotation 0 0 1 -1.5707963
#							children [
#								DEF	toolPitchSensor CylinderSensor {
#									enabled	FALSE
#								}
#								Transform {
#									rotation 0 0 1 1.5707963
#									children [
#						FShape {
#							appearance FAppearance {
#								material DEF toolMaterial FMaterial {
#									diffuseColor "r=0.7;g=0.7;b=0.7;"
#									transparency "0"
#								}
#							}
#							geometry DEF toolGeometry FGeometry	{
#								type "analytical"
#								definition "0.01-x*x-y*y-z*z"
#								bboxCenter 0 0 0
#								bboxSize 5 5 5
#								resolution [100 100 100]
#							}

#									}
#					]}]}
#					]}]}
#					]
#				}
#			]}]}]}]}
#			]
#		}
#	]
#	whichChoice	1
#}

#******************************************************************
#
# Modeling shape
#
#******************************************************************
#################################################################################
########### used for recoord the coordinate of appearance and geometry separately
########### store the handles applied to the shape (which is shown only in show tool)
########## this is invisible except when shown handles
### for storing original definitions of the main shape and each tools

DEF MModel Switch {
	choice [
		DEF	Model Group	{
	children [
		DEF ModelRotationSensor SphereSensor {enabled	TRUE}
		DEF	ModelScaleSensor PlaneSensor {enabled	FALSE}
		DEF	ModelMoveSensor PlaneSensor {enabled	FALSE}
		#RollSensor begin
		Transform {
			rotation 1 0 0 -1.5707963
			children [
				DEF	ModelRollSensor CylinderSensor {enabled	FALSE}
				Transform {
					rotation 1 0 0 1.5707963
					children [
						DEF	ModelYawSensor CylinderSensor {enabled	FALSE}
						#PitchSensor begin
						Transform {
							rotation 0 0 1 -1.5707963
							children [
								DEF	ModelPitchSensor CylinderSensor {enabled	FALSE}
								Transform {
									rotation 0 0 1 1.5707963
									children [

										#----------FMShape
										DEF	Shape FMShape {
											grotation 0 1 0 0
											gtranslation 0 0 0
											gscale 1 1 1

											geoDef "fun=1-sqrt(x*x+y*y+z*z);"
											difusecolorDef "r=0.7;g=0.7;b=0.7;"
																		
											loop FALSE 
											enabled TRUE
											appearance FAppearance {
												material DEF Material FMaterial {
													transparency "1"
													diffuseColor
													"function frep(x1,y1,z1,t){
x=x1;y=y1;z=z1;
r=0.7;g=0.7;b=0.7;return 0;}"						
													patternColor [0,0,1,1,0,0,0,1,0]
													patternKey  []
													
												}
												
												texture3D DEF Texture FTexture3D {
													definition "0"
													type "displacement"
												}
											}
											geometry DEF Geometry FGeometry	{
												definition
											
												"function frep(x1,y1,z1,t){
x=x1;y=y1;z=z1;
fun=1-sqrt(x*x+y*y+z*z);return fun;}"
												bboxCenter 0 0 0
												bboxSize 2.5 2.5 2.5
												resolution [100 100 100]
												parameters [-1,1,-1,1,-1,1]
											}
										}
										#!----------end of FMShape

										#PitchSensor end
										]}]}
										#RollSensor end
										]}]}
									]}	

								] 
								whichChoice	1
					}


DEF HandleGroupSwitch Switch {
			choice [
				DEF	resetGroup Group {
					children [
				DEF HandleGroup Group	{
					children [
					FShape {
						geometry FGeometry { definition	"x=0;y=0;z=0;"
						}
						appearance FAppearance {
							material FMaterial {
								transparency "1"
								diffuseColor "function frep(x1,y1,z1,t){
x=x1;y=y1;z=z1;
r=0.7;g=0.7;b=0.7;return 0;}"						
							}
						}
							}
						
					]
					
				}
			]
			}
			]
			whichChoice	1
		
	}


###################################################
###### the actual showed wholeshape
###########this is visible except when shown handles
###########the final scripting is applied to this

DEF	WholeModelSwitch Switch	{
	choice [
	
DEF WholeModel Group {
			children [
						DEF Touch TouchSensor {enabled FALSE }
						DEF	WholeShapeTransform Transform {
							children [
						DEF	WholeShape FShape {
							polygonizer	"analytical"
							loop FALSE
							enabled TRUE 
							appearance FAppearance {
								material DEF WholeMaterial FMaterial {

									diffuseColor  
									"function frep(x1,y1,z1,t){x=x1;y=y1;z=z1;r=0.7;g=0.7;b=0.7;return 0;}"
									patternColor [0 1 0,1 0 0]
									patternKey [0.3,0.7]
									timeSpan 0 1
									transparency "0"
									emissiveColor "r=0;g=0;b=0;"
									ambientIntensity "1"
									specularColor "r=0;g=0;b=0;"
									shininess "1"
									type ""
								}
								texture3D DEF WholeTexture FTexture3D {
									definition "0"
									type "displacement"
								}
							}
							geometry DEF WholeGeometry FGeometry{
								definition
								"function frep(x1,y1,z1,t){x=x1;y=y1;z=z1;fun=1-sqrt(x*x+y*y+z*z);return fun;}"
								bboxCenter 0 0 0
								bboxSize 2.5 2.5 2.5
								resolution [100 100 100]
								parameters [-1,1,-1,1,-1,1]
								
							}
						#	geometry USE Geometry 
					}
						DEF AddedObject Group {
							children []
						}
						#add for 
						DEF ShapeCoord Switch{
							choice [
								Inline { url "CoordinateAxesShape.wrl"}


							]
							whichChoice	1
						}  
					]
					}
					]
				}

	Transform {
			children [
				 FShape {
						loop FALSE
						enabled TRUE 
						appearance FAppearance {
						material USE Material 
						texture3D USE Texture }
						geometry USE Geometry 
					}
				]
			}
			]
			whichChoice	0
		}


DEF background Background
{
	skyColor 0 0 0
}




#-----added
#here changes a few children-parents relations of AddedObject Group and background etc.
#-------end added


#******************************************************************
#
# Left menu commands
#
#******************************************************************



PROTO simpleText[
	exposedField	SFVec3f		translation		0 0 0
	exposedField	SFRotation	rotation		0 0 1 0
	exposedField	SFVec3f		scale			1 1 1
	exposedField	SFColor		color			1 1 1
	exposedField	SFColor		overColor       0 0 1
	exposedField	MFString	string			""
	eventOut		SFTime		touchTime
]{
	DEF Sensor TouchSensor {
		touchTime IS touchTime
	}
	Transform{
		translation IS translation
		rotation IS	rotation
		scale IS scale
		children Shape {
			appearance Appearance{material DEF TextMaterial Material{}}
			geometry Text{
				string IS string
				fontStyle FontStyle {style "BOLD USE_TEXTURE"  family "Arial"}
			}
		}
	}

	DEF Run Script {
		url	"javascript:
function initialize()
{
	nowColor = color;
}
function color()
{
	if (!isOver) nowColor = color;
}
function overColor()
{
	if (isOver) nowColor = overColor;
}
function isOver()
{
	if (isOver) {
		nowColor = overColor;
	} else {
		nowColor = color;
	}
}
		"
		eventIn SFBool isOver
		eventOut SFColor nowColor
		exposedField SFColor color IS color
		exposedField SFColor overColor IS overColor
	}

	ROUTE Run.nowColor TO TextMaterial.diffuseColor
	ROUTE Run.nowColor TO TextMaterial.emissiveColor
	ROUTE Sensor.isOver	TO Run.isOver
}






################### left menu##########################
Layer3D	{
	translation	-0.5 0
	children
	    [
			DEF	ModesGUI Transform {
				children [
						  	DEF	ModesTextTransform Transform {
								translation	0.26 0 0
								children [
								#-- added

#								Transform	{
#				  							translation 0 0.60 0.15
#											scale 0.1 0.1 0.1
#											children [
#												DEF PhysicsText simpleText {
#													scale 0.85 0.85 0.85
#													translation -2 0 0
#													color 0.8 0.4 1
#													overColor 1 0.8 0.4
#													string "Physics"
#												}
#											]
#										}

								Transform	{
				  							translation 0 0.61 0.15
											scale 0.1 0.1 0.1
											children [
												DEF ShowHandle simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "ShowHandle"
												}
											]
										}

								Transform	{
				  							translation 0 0.68 0.15
											scale 0.1 0.1 0.1
											children [
												DEF MoveableAppearance simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "Appearance"
												}
											]
										}

								Transform	{
				  							translation 0 0.75 0.15
											scale 0.1 0.1 0.1
											children [
												DEF MoveableShape simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "Geometry"
												}
											]
										}

							

								Transform	{
				  							translation 0 0.82 0.15
											scale 0.1 0.1 0.1
											children [
												DEF WholeModelT simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 1 1 0
													overColor 1 0.8 0.4
													string "Shape"
												}
											]
										} 
										#!--end added
					]
					}	

						]
			
			}
		]}






#DEF	OperationMenuSwitch Switch {
#	choice [
Layer3D	{
	translation	-0.5 0
	children
	    [
			DEF	OperationGUI Transform {
				children [
											
							DEF SwOpText Switch	{
								choice [
							DEF	OpTextTransform Transform {
								translation	0.26 -0.09 0
								children [




								Transform	{
							  			translation 0 -0.44 0.15
											scale 0.1 0.1 0.1
										children [
											DEF Undo simpleText { 
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Undo"
											}
										]
									}
									Transform	{
							  			translation 0 -0.38 0.15
											scale 0.1 0.1 0.1
										children [
											DEF Remove simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Remove"
											}
										]
									}
									Transform	{
							  			translation 0 -0.32 0.15
										scale 0.1 0.1 0.1
										children [
											DEF Deposit simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Deposit"
											} 
										] 
									}
									Transform	{
							  			translation 0 -0.24 0.15 
										scale 0.1 0.1 0.1 
										children [
											DEF UndoColor simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4	
												string "Undo Color"
											}
										] 
									}
									Transform	{
				  						translation 0 -0.18 0.15
											scale 0.1 0.1 0.1
										children [ 
											DEF Color simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Color"
											}
										]
									}

									Transform	{
				  						translation 0 -0.1 0.15
											scale 0.1 0.1 0.1
										children [ 
											DEF Rotate simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												#color 0.8 0.4 1
												color 0.4 1 0.8
												overColor 1 0.8 0.4
												string "Rotate"
											}
										]
									}
									Transform	{
				  						translation 0 -0.04 0.15
											scale 0.1 0.1 0.1
										children [
											DEF Roll simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Roll"
											}
										]
									}
									Transform	{
				  						translation 0 0.02 0.15
											scale 0.1 0.1 0.1
										children [
											DEF Pitch simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Pitch"
											}
										]
									}
									Transform	{
				  						translation 0 0.08 0.15
										scale 0.1 0.1 0.1
										children [
											DEF Yaw simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Yaw"
											}
										]
									}
									Transform	{
				  						translation 0 0.14 0.15
										scale 0.1 0.1 0.1
										children [
											DEF Displace simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Displace"
											}
										]
									}
									Transform	{
				  						translation 0 0.20 0.15
										scale 0.1 0.1 0.1
										children [
											DEF Scale simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Scale"
											}
										]
									}
									Transform	{
				  						translation 0 0.26 0.15
										scale 0.1 0.1 0.1
										children [
											DEF Move simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "Move"
											}
										]
									}
									Transform	{
				  						translation 0 0.34 0.15
										scale 0.1 0.1 0.1
										children [
											DEF Cancel simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "CancelTool"
											}
										]
									}
								Transform	{
				  							translation 0 0.40 0.15
											scale 0.1 0.1 0.1
											children [
												DEF ResetTool simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "ResetTool"
												}
											]
										}

								Transform	{
				  							translation 0 0.46 0.15
											scale 0.1 0.1 0.1
											children [
												DEF ResetShape simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "ResetShape"
												}
											]
										}

								Transform	{
				  							translation 0 0.54 0.15
											scale 0.1 0.1 0.1
											children [
												DEF CoordinateSys simpleText {
													scale 0.6 0.6 0.6
													translation	-2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "CoordSys"
												}
											]
										}
								Transform	{
				  							translation 0 0.60 0.15
											scale 0.1 0.1 0.1
											children [
												DEF BoundingBox simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "BBox"
												}
											]
										}

										#-- added
				

						#!--end added		
					]
				}	


								DEF	OpTextTransform2 Transform {
								translation	0.26 -0.09 0
								children [


									Transform	{
				  						translation 0 -0.15 0.15
											scale 0.1 0.1 0.1
										children [USE	Undo]
									}

									Transform	{
				  						translation 0 -0.07 0.15
											scale 0.1 0.1 0.1
										children [USE	Rotate]
									}
									Transform	{
				  						translation 0 -0.01 0.15
											scale 0.1 0.1 0.1
										children [USE	Roll]
									}
									Transform	{
				  						translation 0 0.05 0.15
											scale 0.1 0.1 0.1
										children [USE	Pitch]
									}
									Transform	{
				  						translation 0 0.11 0.15
										scale 0.1 0.1 0.1
										children [USE	Yaw]
									}
									Transform	{
				  						translation 0 0.19 0.15
										scale 0.1 0.1 0.1
										children [USE	Scale]
									}
									Transform	{
				  						translation 0 0.27 0.15
										scale 0.1 0.1 0.1
										children [
											DEF MoveZ simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "MoveZ"
											}
										]
									}
									Transform	{
				  						translation 0 0.33 0.15
										scale 0.1 0.1 0.1
										children [
											DEF MoveY simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "MoveY"
											}
										]
									}
									Transform	{
				  						translation 0 0.39 0.15
										scale 0.1 0.1 0.1
										children [
											DEF MoveX simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "MoveX"
											}
										]
									}
#								Transform	{
#				  							translation 0 0.47 0.15
#											scale 0.1 0.1 0.1
#											children [USE	Reset]
#										}

								Transform	{
				  							translation 0 0.47 0.15
											scale 0.1 0.1 0.1
											children [
												DEF ResetCoord simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "ResetCoord"
												}
											]
										}
								Transform	{
				  							translation 0 0.55 0.15
											scale 0.1 0.1 0.1
											children [USE	CoordinateSys]
										}
								Transform	{
				  							translation 0 0.60 0.15
											scale 0.1 0.1 0.1
											children [USE	BoundingBox]
										}

										#-- added
				

						#!--end added		
					]
				}

				DEF	OpTextTransform3 Transform {
								translation	0.26 -0.09 0
								children [

								Transform	{
				  						translation 0 0.21 0.15
										scale 0.1 0.1 0.1
										children [
											DEF UndoDele simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "UndoDele"
											}
										]
									}
			

								Transform	{
				  							translation 0 0.26 0.15
											scale 0.1 0.1 0.1
											children [
												DEF DeleTool simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "DeleTool"
												}
											]
										}

								Transform	{
				  						translation 0 0.34 0.15
										scale 0.1 0.1 0.1
										children [
											DEF ShowAll simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "ShowAll"
											}
										]
									}
								Transform	{
				  						translation 0 0.42 0.15
										scale 0.1 0.1 0.1
										children [
											DEF UndoHide simpleText {
												scale 0.6 0.6 0.6
												translation -2 0 0
												color 0.8 0.4 1
												overColor 1 0.8 0.4
												string "UndoHide"
											}
										]
									}
			

								Transform	{
				  							translation 0 0.47 0.15
											scale 0.1 0.1 0.1
											children [
												DEF HideTool simpleText {
													scale 0.6 0.6 0.6
													translation -2 0 0
													color 0.8 0.4 1
													overColor 1 0.8 0.4
													string "HideTool"
												}
											]
										}

								Transform	{
				  							translation 0 0.55 0.15
											scale 0.1 0.1 0.1
											children [USE	CoordinateSys]
										}
								Transform	{
				  							translation 0 0.60 0.15
											scale 0.1 0.1 0.1
											children [USE	BoundingBox]
										}

										#-- added
				

						#!--end added		
					]
				}
			]
			#--end choice
			whichChoice	0

			}
			#--end of switch

					
						
						]
			
			}
		]}

#	]
#	#--end of choice
#}
##--end of switch


	


 #!--end added

#******************************************************************
#
# To send internal message. to detect when the client enters the scene
#
#******************************************************************



DEF	Keybord KeySensor {
}

DEF SendTimer TimeSensor {
	cycleInterval 0.01
	enabled	FALSE
	loop TRUE
}

DEF InitTimer TimeSensor {
	cycleInterval 0.1
	loop TRUE
}


#******************************************************************
#
# Core part of modeling
#
#******************************************************************

DEF Modeller Script {
	mustEvaluate TRUE
	directOutput TRUE

	eventIn	SFBool saveAssemble
	field SFString modelStr ""

	eventIn	SFVec3f	coordinateIn
	eventIn	SFVec3f	normalIn
	eventIn	SFTime click
	eventIn	SFBool isOver
	eventOut SFString sendMessage
	eventIn	SFInt32	key
	eventIn	SFBool boundingBox1
	eventIn	SFTime boundingBox
	eventIn	SFTime coordinateSys

	#--added
	eventIn	SFTime moveableShape
	eventIn	SFTime moveableAppearance
	eventIn	SFTime wholeModelT
	eventIn	SFBool resetCoord

	eventIn	SFBool resetToolN

	eventIn	SFBool keyflag
	#!--end added
	eventIn	SFTime texexport
	eventIn	SFTime texsave
	eventOut SFString receiveChat

	eventIn	SFBool exportwrl
	eventIn	SFBool savemodel

	eventIn	SFTime load
	eventIn	SFTime resetshape

	eventIn	SFTime remove
	eventIn	SFTime deposit
	eventIn	SFTime cancel
	eventIn	SFTime rotate
	eventIn	SFTime roll
	eventIn	SFTime pitch
	eventIn	SFTime yaw
	eventIn	SFTime displace
	eventIn	SFTime scale
	eventIn	SFTime undo
	eventIn	SFTime resetTool
	eventIn	SFTime resetCoordinate

	eventIn	SFTime move

	eventIn	SFTime edit

	field MFString newurl [ "OnEvent( par1, par2 )" ]
	field MFString refreshurl [ "refresh( par1, par2 )" ]

    field MFString param [ "" "" ]
	eventIn	SFBool refreshfromchat
	eventIn	SFBool loadmodel

	#--added for moveXYZ
	eventIn	SFTime moveX
	eventIn	SFTime moveY
	eventIn	SFTime moveZ
	field SFInt32 moveXYZ -1
	eventOut SFColor moveXcolor
	eventOut SFColor moveYcolor
	eventOut SFColor moveZcolor

	eventOut SFInt32 showShapeCoord
	eventOut SFVec3f bboxCenter

	field SFVec3f bboxcenter 0 0 0
	field SFVec3f pgtrans 0 0 0
	#!--end added for moveXYZ

	eventIn	SFTime applycolor
	eventIn	SFTime undocolor
	eventIn	SFString lock
	eventOut SFString requestLock
	eventIn	SFString initLock
	eventOut SFString outInit
	eventIn	SFString receiveMessage
	eventIn	SFString msgLock
	eventOut SFString setMsgLock
	eventIn SFTime sendOneMsg
	eventIn	SFTime init
	eventIn	SFString loadModel
	eventIn MFString receiveChat1
	eventOut SFInt32 showHideTool

	eventIn	SFRotation toolRotationIn
	eventIn	SFVec3f	toolTranslationIn
	eventIn	SFRotation toolLocalRotationIn
	eventIn	SFVec3f	toolScaleIn
	eventIn	SFVec3f	toolMoveIn
	eventIn SFRotation toolRollIn
	eventIn SFRotation toolPitchIn
	eventIn SFRotation toolYawIn

	#--added
	eventIn	SFRotation modelRotationIn
#	eventIn	SFVec3f	modelTranslationIn
	eventIn	SFVec3f modelScaleIn
	eventIn	SFVec3f	modelMoveIn
	eventIn	SFRotation modelRollIn
	eventIn	SFRotation modelPitchIn
	eventIn	SFRotation modelYawIn

	eventIn	SFBool	tick

	eventIn	SFBool okUp

	eventIn	SFBool gtransUp
	eventIn	SFBool atransUp

	eventIn	SFBool toolUp

	eventIn SFVec3f gtrans 
	eventIn SFVec3f gscale
	eventIn SFRotation grot 

	eventIn SFVec3f atrans 
	eventIn SFVec3f ascale
	eventIn SFRotation arot 


	field SFVec3f gtransf 0 0 0
	field SFVec3f gscalef 1 1 1
	field SFRotation grotf 0 1 0 0

	field SFVec3f atransf 0 0 0
	field SFVec3f ascalef 1 1 1
	field SFRotation arotf 0 1 0 0


	field SFBool coordgeometryflag TRUE
	field SFBool coordappearanceflag TRUE
	eventOut SFInt32 geometrycoord
	eventOut SFInt32 appearancecoord

	field SFBool boxgeometryflag FALSE
	field SFBool boxappearanceflag FALSE
	eventOut SFInt32 geometrybox
	eventOut SFInt32 appearancebox
	
	#!--end added


	eventOut SFRotation	toolRotationOut
	eventOut SFVec3f toolTranslationOut
	eventOut SFVec3f toolScaleOut
	eventOut SFVec3f toolMoveOut
	eventOut SFRotation	toolRollOut
	eventOut SFRotation	toolPitchOut
	eventOut SFRotation	toolYawOut
	eventOut SFBool	touchSensor
	eventOut SFBool	toolRotateSensor
	eventOut SFBool	toolDisplaceSensor
	eventOut SFBool	toolScaleSensor
	eventOut SFBool	toolMoveSensor
	eventOut SFBool	toolRollSensor
	eventOut SFBool	toolPitchSensor
	eventOut SFBool	toolYawSensor

	#--added
	eventOut SFInt32 showModel
	eventOut SFInt32 showOp


	eventOut SFRotation	shapeRotationOut
	eventOut SFVec3f shapeTranslationOut
	eventOut SFVec3f shapeScaleOut

	eventOut SFRotation	appearanceRotationOut
	eventOut SFVec3f appearanceTranslationOut
	eventOut SFVec3f appearanceScaleOut


	eventOut SFBool	modelRotateSensor
	eventOut SFBool	modelDisplaceSensor
	eventOut SFBool	modelScaleSensor
	eventOut SFBool	modelMoveSensor
	eventOut SFBool	modelRollSensor
	eventOut SFBool	modelYawSensor
	eventOut SFBool	modelPitchSensor

	eventOut SFRotation	modelRotateOffset
#	eventOut SFVec3f modelDisplaceOffset
	eventOut SFVec3f modelScaleOffset
	eventOut SFVec3f modelMoveOffset
	eventOut SFFloat modelRollOffset
	eventOut SFFloat modelPitchOffset
	eventOut SFFloat modelYawOffset

	#!--end added

	eventOut SFColor toolRotateColor
	eventOut SFColor toolDisplaceColor
	eventOut SFColor toolScaleColor
	eventOut SFColor toolMoveColor
	eventOut SFColor toolRollColor
	eventOut SFColor toolPitchColor
	eventOut SFColor toolYawColor
	eventOut SFRotation	toolRotateOffset
	eventOut SFVec3f toolDisplaceOffset
	eventOut SFVec3f toolScaleOffset
	eventOut SFVec3f toolMoveOffset
	eventOut SFFloat toolRollOffset
	eventOut SFFloat toolPitchOffset
	eventOut SFFloat toolYawOffset

	field SFNode wholematerial USE WholeMaterial
	field SFNode wholetexture USE WholeTexture
	field SFNode wholeshapetransform USE WholeShapeTransform
	field SFNode wholeshape USE	WholeShape
 	field SFNode wholegeometry USE WholeGeometry

	field SFNode geometry USE Geometry
  	field SFNode material USE Material
	field SFNode shape USE Shape
	field SFNode texture USE Texture

	field SFNode sendTimer USE SendTimer
	field SFNode initTimer USE InitTimer
	field SFNode toolGeometry USE ToolGeometry
	field SFNode toolMaterial USE ToolMaterial
	field SFNode toolTransform USE ToolTransform
	field SFNode toolLocalRotationTransform USE	ToolLocalRotationTransform
	field SFNode toolLocalTransform USE	ToolLocalTransform
	field SFNode toolRollTransform USE ToolRollTransform
	field SFNode toolPitchTransform USE	ToolPitchTransform
	field SFNode toolYawTransform USE ToolYawTransform

	field SFVec3f toolTranslationValue 0 0 0
	field SFRotation toolRotationValue 0 0 1 0
	field SFString operation "|("
	field SFVec3f coord 0 0 0
	field SFString lockUser ""
	field SFBool initialized FALSE
	field SFString initUser ""
	field SFString msgUser ""
	field MFString sendingMessages []
	field SFInt32 sendingIndex 0
	field SFBool flag FALSE
	field SFBool flag1 FALSE  #for bounding box
	field SFInt32 removed 0
	field SFString receivedMessage ""
	field SFString nowShape ""
	field SFString nowColor ""
	field SFBool requested FALSE
	field SFBool receiving FALSE
	field SFVec3f coordinate 0 0 0
	field SFVec3f normal 0 0 1
	field MFString address ["CoordinateAxes.wrl"]
	field SFString event "addChildren"
	field SFNode addedObject USE AddedObject
	field SFNode model USE Model
	#field SFNode tempNode USE TempNode
	field MFNode tempNode []
	field MFNode tempNode1 []
	field SFString str ""
	field SFString str1 ""
	field MFFloat dd []
	field MFFloat dds []
	field SFNode CoordinateSys USE CoordinateSys
	field SFNode BoundingBox USE BoundingBox
	field SFNode touch USE Touch

	#--added
	#field SFRotation modelRotationOut 0 0 1 0
	#field SFVec3f modelTranslationOut 0 0 0
	#field SFVec3f modelScaleOut	1 1 1

	field SFRotation zeroRotation 0 0 1 0
	field SFVec3f zeroTranslation 0 0 0
	field SFVec3f zeroScale	0 0 0

	#field SFVec3f modelMoveOut 0 0 0
	#field SFRotation	modelRollOut 0 0 1 0
	#field SFRotation	modelPitchOut 1 0 0 0
	#field SFRotation	modelYawOut 0 1 0 0

	#field MFFloat modelm [1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1]

	field SFBool moveshapeflag FALSE
	field SFBool moveappearanceflag FALSE
	field SFBool wholemodelflag TRUE

	field SFNode MoveableAppearance USE	MoveableAppearance
	field SFNode WholeModel USE	WholeModel 
	field SFNode WholeModelT USE WholeModelT
	field SFNode MoveableShape USE MoveableShape


	

	field SFInt32 ticktock 0
	field SFBool  firstOperation TRUE
	field SFString initColor ""
	field SFString prevColor ""
	field SFString tempDef ""
	field SFBool shouldApplyOp TRUE

	field MFRotation GRotation []
	field MFVec3f GTranslation []
	field MFVec3f GScale []
	field MFRotation MRotation []
	field MFVec3f MTranslation []
	field MFVec3f MScale []
	field SFInt32 GeometryArray 0
	field SFInt32 AppearanceArray 0


	field SFInt32 GHandleNum 0
	field SFInt32 GID 0
	field MFString GHandName [""]
	field MFNode handle []	#for temple handle node
	field SFNode addHandle USE HandleGroup

	field SFNode resetGroup USE	resetGroup

	field SFNode handlegroupswitch USE HandleGroupSwitch
	
	field SFNode TouchedHandle NULL

	field MFVec3f GHandleTrans []
	field MFVec3f GHandleScale []
	field MFRotation GHandleRotate []
	field MFRotation GHandleYaw []
	field MFRotation GHandlePitch []
	field MFRotation GHandleRoll []
	field MFRotation GHandleLocalRotate []
	field MFVec3f GHandleLocalTrans []
	field MFString GHandleOper []

	field MFString GHandleDef [""]

	########## for storing the local bbox of tool#########
	field MFVec3f GHandleBoxC []
	field MFVec3f GHandleBoxS []

	### for bbox in world coordinate and it is AABB #######
	field MFVec3f GHandleAABBC []
	field MFVec3f GHandleAABBS []



	field SFInt32 AHandleNum 0
	field SFInt32 AID 0
	field MFString AHandName [""]

	field MFVec3f AHandleTrans []
	field MFVec3f AHandleScale []
	field MFRotation AHandleRotate []
	field MFRotation AHandleYaw []
	field MFRotation AHandlePitch []
	field MFRotation AHandleRoll []
	field MFRotation AHandleLocalRotate []
	field MFVec3f AHandleLocalTrans []
	#field MFString AHandleOper []

	field MFString AHandleDef [""]
	field MFFloat AColorR []
	field MFFloat AColorG []
	field MFFloat AColorB []
	field MFFloat AAlpha []

	eventIn	SFTime ShowHandleIn
	eventIn	SFTime HideToolIn
	eventIn	SFTime UndoHideIn

	eventIn	SFTime DeleToolIn
	eventIn	SFTime UndoDeleIn

	eventIn	SFTime ShowAllIn

	eventOut SFColor ShowHandleColor
	eventOut SFColor HideToolColor
	eventOut SFColor DeleToolColor
	
	field MFString HidedTool []
	field SFInt32 hidedN 0

	field MFString DeledTool []
	field SFInt32 deledN 0 

	eventOut SFInt32 ShowHandleOut
	field SFBool ShowHandleFlag FALSE
	field SFBool HideToolFlag FALSE
	field SFBool DeleToolFlag FALSE

	field SFInt32 reservChoice 0

	field SFNode tempn1 NULL
	#field SFNode tempn2 NULL

	eventIn	SFTime HandleDoubleTouched
	eventIn	SFString TouchID

	eventOut SFInt32 wholemodelswitch

	field SFInt32 reservAN 0
	field SFInt32 reservGN 0

	eventIn SFVec3f	bbox2


	field SFString tooldefinition ""
	field SFString toolmaterial ""
	field SFString toolalpha ""
	
	field SFVec3f tooltransformTrans 0 0 0
	field SFRotation tooltransformRot 0 0 1 0

	field SFVec3f toollocaltransformScale 0 0 0
	field SFVec3f toollocaltransformTrans 0 0 0
	field SFRotation toollocalrotationtransformRot 0 0 1 0

	field SFRotation toolrolltransformRot 0 0 1 0
	field SFRotation toolpitchtransformRot 1 0 0 0
  	field SFRotation toolyawtransformRot 0 1 0 0

	field SFString toolname ""

	########################*acceleration for tool local bounding box
	field SFString resetHG "DEF HandleGroup Group	{children [FShape {geometry FGeometry { definition	\"x=0;y=0;z=0;\"}appearance FAppearance {material FMaterial {transparency \"1\" diffuseColor \"function frep(x1,y1,z1,t){x=x1;y=y1;z=z1;r=0.7;g=0.7;b=0.7;return 0;}\"}}}]}	" 
	field MFNode resetHGN []


	#------store the tool local bounding box information
	field SFVec3f toolBBoxCenter 0 0 0
	field SFVec3f toolBBoxSize 0.25 0.25 0.25

	#----------acceleration VOTree

	field SFString VOTree ""
	field SFString boxlist ""

	#------end VOTree use


	#----add for more appearance
	eventOut SFString emissiveColor 
	eventOut SFString ambientIntensity
	eventOut SFString specularColor
	eventOut SFString shininess
	eventOut SFString matType
	eventOut SFString transparency
	#---end of added for more appearance

	#--add for wholetexture
	eventOut SFString texDef
	eventOut SFVec2f texTimespan
	eventOut SFString texType
	eventOut MFFloat texParameters

	field SFString texdef "0"
	field SFVec2f textimespan 0 1
	field SFString textype "displacement"
	field MFFloat texparameters [-1,1,-1,1,-1,1]
	#--end of add


	field SFString focusedtool ""
	field SFNode tempn3 NULL	    #for focused tool

	eventIn SFBool	EditTool



	#directOutput TRUE
	url	"javascript:
function initialize()
{
	showHideTool = 1;
	touchSensor = true;

	keyflag = false;

	shapeTranslationOut = zeroTranslation;
	
	showShapeCoord = 1;
	
	AHandleNum = 0;
	GHandleNum = 0;
	reservAN = 0;
	reservGN = 0;


//	resetHGN = addHandle.copy(); 
	resetHGN = Browser.createVrmlFromString(resetHG);
//	print('resetHGN:'+resetHGN);
//	print(addHandle);
//	else print('oh');



}

function resetToolN(){
//	AHandleNum = 0;
//	GHandleNum = 0;
//	reservAN = 0;
//	reservGN = 0;

//	print('AHandleNum:'+AHandleNum);
//	print('GHandleNum:'+GHandleNum);
//	print('reservAN:'+reservAN);
//	print('reservGN:'+reservGN);
	resetshape();
}



//******************************************************************
//
// To split loaded string
//
//******************************************************************



function split(s, c)
{
	var ss = new Array('');
	var j = 0;
	for(var i=0;i<s.length;++i)
		if(s.charAt(i) == c)
		{
			++j;
			ss[j] = '';
		}
		else
			ss[j] += s.charAt(i);
	return ss;
}



//******************************************************************
//
// To send complete message, tt - type of message, mm - message itself
//
//******************************************************************



function send(tt, mm)
{
	var pos = 0;
	var now = '';
	var len = mm.length;

	for(var i=0;i<mm.length;++i)
	{
		if (mm.charAt(i) == '\\n')
			now += '\\\\';
		else
			now += mm.charAt(i);
	}
	mm = now;

	sendingMessages[sendingMessages.length] = '$BEGIN$';

	while (pos < len)
	{
		var end = len;

		if (len - pos > 128)
		{
			end = pos + 128;
		}

		sendingMessages[sendingMessages.length] = mm.substring(pos, end);

		pos = end;
	}

	sendingMessages[sendingMessages.length] = '$END$' + tt;
	if (msgUser == '')
	{
		// Compete for the lock
		//setMsgLock = Browser.myAvatarName;
	}
	sendTimer.enabled = TRUE;
}



//******************************************************************
//
// To load the model
//
//******************************************************************


function loadModel()
{
	//if (split(loadModel, '`').length < 15) return;
	if (split(loadModel, '`').length < 53) return;
	send('load', loadModel);
}



//******************************************************************
//
// To initialize everything
//
//******************************************************************


function init()
{
	initialized = TRUE;
	//outInit = Browser.myAvatarName;

}




//******************************************************************
//
// To send one piece of message to the server. It is called by the send timer.
//
//******************************************************************



function sendOneMsg()
{
	sendTimer.enabled = FALSE;
	var message = new String(sendingMessages[sendingIndex++]);
	if (sendingMessages.length == sendingIndex)
	{
		sendingIndex = 0;
		sendingMessages = new MFString();
	}
	sendMessage = '@' + message + '#';
}
function parseFloatArray(s)
{
	var dd = new MFFloat();
	var ss = split(s, ',');
	for(var i=0;i<ss.length;++i)
	{
		dd[i] = parseFloat(ss[i]);
	}

	return dd;
}
function parseVec3f(s)
{
	var dd = parseFloatArray(s);
	return new SFVec3f(dd[0], dd[1], dd[2]);
}

function parseFieldFloatArray(s){
	var dd = new MFFloat();
	var ss = split(s, ' ');
	for(var i=0;i<ss.length;++i)
	{
		dd[i] = parseFloat(ss[i]);
	}

	return dd;
}

function parseFieldVec3f(s){

	print(s);
	var dd = parseFieldFloatArray(s);

	print(dd);

	return new SFVec3f(dd[0], dd[1], dd[2]);
}


function parseSFRotation(s){
	var rr = parseFloatArray(s);
	return new SFRotation(rr[0],rr[1],rr[2],rr[3]/*x, y, z, angle*/);
}
function parseVec2f(s)
{
	var dd = parseFloatArray(s);
	return new SFVec2f(dd[0], dd[1]);
}
function parseIntArray(s)
{
	var dd = new MFInt32();
	var ss = split(s, ',');
	for(var i=0;i<ss.length;++i)
	{
		dd[i] = parseInt(ss[i]);
	}

	return dd;
}

function parseColorArray(s)
{
	var dd = parseFloatArray(s);
	var out = new MFColor();
	for(var i=0;i*3+2<dd.length;++i)
	{
		out[i] = new SFColor(dd[i*3], dd[i*3+1], dd[i*3+2]);
	}

	return out;
}

	   //assembleMFString
	   //assembleVec3fArray
	   //assembleSFRotationArray
function assembleSFRotation(dd)
{
	var s = '';
	s = dd[0] + ',' + dd[1] + ',' + dd[2]+','+dd[3];
	return s;
}

function assembleMFString(ss,n){
	var s='';
	for(var i=0;i<n;i++){
		if(i!=(n-1)) s = s+ss[i]+'#';
		else s = s+ss[i];
	}
	return s;
}

function assembleVec3fArray(vv,n){
	var v='';
	for(var i=0;i<n;i++){
		v = v+vv[i][0]+','+vv[i][1]+','+vv[i][2];
		if(i!=(n-1)) v = v+'#';
	}
	return v;
}

function assembleSFRotationArray(vv,n){
	var v='';
	for(var i=0;i<n;i++){
		v = v+vv[i][0]+','+vv[i][1]+','+vv[i][2]+','+vv[i][3];
		if(i!=(n-1)) v = v+'#';
	}
	return v;
}

function assembleVec3f(dd)
{
	return dd[0] + ',' + dd[1] + ',' + dd[2];
}																	   
function assembleVec2f(dd)
{
	return dd[0] + ',' + dd[1];
}
function assembleFloatArray(dd)
{
	var s = '';
	var first = true;
	for(var i=0;i<dd.length;++i)
	{
		if (first)
		{
			first = false;
		}
		else
		{
			s += ',';
		}
		s += dd[i];
	}
	return s;
}
function assembleColorArray(dd)
{
	var s = '';
	var first = true;
	for(var i=0;i<dd.length;++i)
	{
		if (first)
		{
			first = false;
		}
		else
		{
			s += ',';
		}
		s += assembleVec3f(dd[i]);
	}
	return s;
}



//******************************************************************
//
// To receive message
//
//#******************************************************************



function receiveMessage(ss)
{
	if (ss[0] != '@' || ss[ss.length-1] != '#') return;
	var now = '';
	for(var i=1;i<ss.length-1;++i)
	{
		if (ss.charAt(i) == '\\\\')
			now += '\\n';
		else
			now += ss.charAt(i);
	}
	ss = now;
	if (receiving && ss.substring(0, 5) == '$END$')
	{
		receiving = false;
		var type = ss.substring(5, ss.length);


//******************************************************************
//
// To analyze what type of message
//
//******************************************************************


		if (type == 'shape' && initialized)
		{
			//initialized = TRUE;
			wholegeometry.definition = receivedMessage;
			print('wholegeometry.definition:\\n'+receivedMessage);

				}
		if (type == 'color' && initialized)
		{
			material.diffuseColor = receivedMessage;
		}
		else if ((type == 'initShape' && !initialized) || (type == 'load'))
		{
			// The format would be
			// `<geodef>`<colordef>`<bbcenter>`<bbsize>`<resolution>`<parameters>`<patternColors>`<patternKeys>`<polygonizer>
			// `<cycleinterval>`<materialtimespan>`<texture>`<texturetimespan>`<geometrytimespan>`

			//the format would be
			//'<geodef>'<geotrans>'<georotate>'<geoscale>	  //1,2,3,4
			//'<geoboxcenter>'<geoboxsize>'<resolution>'<parameters>'<patterncolor>'<patternkey> //5,6,7,8,9,10
			//'<polygonizer>'<cycleinterval>'<materaltimespan>'<texturedefinition>'<textimespan> //11,12,13,14,15
			//'<geometrytimespan> //16
			//'<diffusecolordef>'<atrans>'<arotation>'<ascale> //17,18,19,20
			//'<GHandleNum>'<GHandleDef>'<GHandleTrans>'<GHandleRotate>'<GHandleScale>'<GHandleYaw>'<GHandlePitch>'<GHandleRoll>'<GHandleLocalRotate>
			//'<GHandleLocalTrans>'<GHandleOper>
			//'<AHandleNum>'<AHandleDef>'<AHandleTrans>'<AHandleRotate>'<AHandleScale>'<AHandleYaw>'<AHandlePitch>'<AHandleRoll>'<AHandleLocalRotate>
			//'<AHandleLocalTrans>'<AColorR>'<AColorG>'<AColorB>'<AAlpha>
//******************************************************************
//
// Event loop
//
//******************************************************************

			initialized = TRUE;
			var shapeDef = split(receivedMessage, '`');
			wholeshape.parents = new MFNode(wholegeometry);

			shape.geoDef = shapeDef[1];
			shape.gtranslation = parseVec3f(shapeDef[2]);
			shape.grotation = parseSFRotation(shapeDef[3]);
			shape.gscale = parseVec3f(shapeDef[4]);

			wholegeometry.bboxCenter = parseVec3f(shapeDef[5]);
			toolGeometry.bboxCenter = parseVec3f(shapeDef[5]);
			wholegeometry.bboxSize = parseVec3f(shapeDef[6]);
			toolGeometry.bboxSize = parseVec3f(shapeDef[6]);

			//wholegeometry.resolution = parseFloatArray(shapeDef[5]);
			wholegeometry.resolution = parseIntArray(shapeDef[7]);
			//toolGeometry.resolution = parseFloatArray(shapeDef[5]);
			toolGeometry.resolution = parseIntArray(shapeDef[7]);
			
			wholegeometry.parameters = parseFloatArray(shapeDef[8]);
			toolGeometry.parameters = parseFloatArray(shapeDef[8]);

			wholematerial.patternColor = parseColorArray(shapeDef[9]);
			wholematerial.patternKey = parseFloatArray(shapeDef[10]);
			wholematerial.transparency = shapeDef[11];
			wholematerial.emissiveColor = shapeDef[12];
			wholematerial.ambientIntensity = shapeDef[13];
			wholematerial.specularColor = shapeDef[14];
			wholematerial.shininess = shapeDef[15];
			wholematerial.type = shapeDef[16];
			wholeshape.polygonizer = shapeDef[17];
			wholeshape.cycleInterval = parseFloat(shapeDef[18]);

			wholeshape.loop  = ((shapeDef[19]=='1') ? 'TRUE' : 'FALSE');

			//wholeshape.loop = shapeDef[19];
			wholematerial.timeSpan = parseVec2f(shapeDef[20]);
			wholetexture.definition = shapeDef[21];
			wholetexture.timeSpan = parseVec2f(shapeDef[22]);
			wholegeometry.timeSpan = parseVec2f(shapeDef[23]);

			shape.difusecolorDef =	shapeDef[24];
			shape.atranslation = parseVec3f(shapeDef[25]);
			shape.arotation = parseSFRotation(shapeDef[26]);
			shape.ascale = parseVec3f(shapeDef[27]);

				//'<GHandleNum>'<GHandleDef>'<GHandleTrans>'<GHandleRotate>	//21,22,23,24
			//'<GHandleScale>'<GHandleYaw>'<GHandlePitch>'<GHandleRoll>'<GHandleLocalRotate> //25,26,27,28,29

			//'<GHandleLocalTrans>'<GHandleOper> //30,31


			var id = '';
			var strHandle = '';

			resetHGN = Browser.createVrmlFromString(resetHG);
			resetGroup.children = resetHGN;
			addHandle = resetGroup.getSubNodeById('@HandleGroup');
			
		
			GHandleNum = parseInt(shapeDef[28]);
			reservGN = GHandleNum;
			GID = GHandleNum;
			
			SSGHandleDef = split(shapeDef[29], '#');
			SSGHandleTrans = split(shapeDef[30], '#');
			SSGHandleRotate = split(shapeDef[31], '#');
			SSGHandleScale = split(shapeDef[32], '#');
			SSGHandleYaw = split(shapeDef[33], '#');
			SSGHandlePitch = split(shapeDef[34], '#');
			SSGHandleRoll = split(shapeDef[35], '#');
			SSGHandleLocalRotate = split(shapeDef[36], '#');
			SSGHandleLocalTrans = split(shapeDef[37], '#');
			SSGHandleOper = split(shapeDef[38], '#');
			
			
			for(var i=0;i<GHandleNum;i++){
			id = 'G'+i;
			strHandle = '';

			GHandleDef[i] = SSGHandleDef[i];
			GHandleTrans[i] = parseVec3f(SSGHandleTrans[i]);
			GHandleRotate[i] = parseSFRotation(SSGHandleRotate[i]);
			GHandleScale[i] = parseVec3f(SSGHandleScale[i]);
			GHandleYaw[i] = parseSFRotation(SSGHandleYaw[i]);
			GHandlePitch[i] = parseSFRotation(SSGHandlePitch[i]);
			GHandleRoll[i] = parseSFRotation(SSGHandleRoll[i]);
			GHandleLocalRotate[i] = parseSFRotation(SSGHandleLocalRotate[i]);
			GHandleLocalTrans[i] = parseVec3f(SSGHandleLocalTrans[i]);
			GHandleOper[i] = SSGHandleOper[i];
											  		
			GHandName[i] = id;

			strHandle+= 'DEF '+id+'  HandleTool{\n';
			strHandle+='name \"'+id+'\"\n';
			strHandle+='definition \"'+GHandleDef[i]+'\"\n';
			//strHandle+='diffusecolor \"'+toolMaterial.diffuseColor+'\"\n';
			//strHandle+='materTransparency \"'+toolMaterial.transparency+'\"\n';
			strHandle+='transformTrans '+ GHandleTrans[i]+'\n';
			strHandle+='transformRot '+ GHandleRotate[i]+'\n';
			strHandle+='localrotationtransformRot '+ GHandleLocalRotate[i]+'\n';
			strHandle+='localtransformTrans '+ GHandleLocalTrans[i]+'\n';
			strHandle+='localtransformScale '+ GHandleScale[i]+'\n';
			strHandle+='rolltransformRot '+ GHandleRoll[i]+'\n';
			strHandle+='pitchtransformRot '+ GHandlePitch[i]+'\n';
			strHandle+='yawtransformRot '+ GHandleYaw[i]+'\n';
			strHandle+='}\n';

			handle = Browser.createVrmlFromString(strHandle);							
			addHandle.addChildren = handle;	
		
 			Browser.addRoute(handle,'TouchID', Browser.getScript(),'TouchID');
	   

			}
		//	<AColorR>'<AColorG>'<AColorB>'<AAlpha>
			AHandleNum = parseInt(shapeDef[39]);
			reservAN = AHandleNum;
			AID = AHandleNum;

			SSAHandleDef = split(shapeDef[40], '#');
			SSAHandleTrans = split(shapeDef[41], '#');
			SSAHandleRotate = split(shapeDef[42], '#');
			SSAHandleScale = split(shapeDef[43], '#');
			SSAHandleYaw = split(shapeDef[44], '#');
			SSAHandlePitch = split(shapeDef[45], '#');
			SSAHandleRoll = split(shapeDef[46], '#');
			SSAHandleLocalRotate = split(shapeDef[47], '#');
			SSAHandleLocalTrans = split(shapeDef[48], '#');
			SSAColorR = split(shapeDef[49], ',');
			SSAColorG = split(shapeDef[50], ',');
			SSAColorB = split(shapeDef[51], ',');
			SSAAlpha = split(shapeDef[52], ',');

			for(var i=0;i<AHandleNum;i++){
				id = 'A'+i;
				strHandle = '';

				AHandleDef[i] = SSAHandleDef[i];
				AHandleTrans[i] = parseVec3f(SSAHandleTrans[i]);
				AHandleRotate[i] = parseSFRotation(SSAHandleRotate[i]);
				AHandleScale[i] = parseVec3f(SSAHandleScale[i]);
				AHandleYaw[i] = parseSFRotation(SSAHandleYaw[i]);
				AHandlePitch[i] = parseSFRotation(SSAHandlePitch[i]);
				AHandleRoll[i] = parseSFRotation(SSAHandleRoll[i]);
				AHandleLocalRotate[i] = parseSFRotation(SSAHandleLocalRotate[i]);
				AHandleLocalTrans[i] = parseVec3f(SSAHandleLocalTrans[i]);
				AColorR[i] = parseFloat(SSAColorR[i]);
				AColorG[i] = parseFloat(SSAColorG[i]);
				AColorB[i] = parseFloat(SSAColorB[i]);
				AAlpha[i] = parseFloat(SSAAlpha[i]);
				AHandName[i] = id;
				
				strHandle+= 'DEF '+id+'  HandleTool{\n';
				strHandle+='name \"'+id+'\"\n';
				strHandle+='definition \"'+AHandleDef[i]+'\"\n';
				strHandle+='diffusecolor \"r='+AColorR[i]+';g='+AColorG[i]+';b='+AColorB[i]+';\"\n';
				strHandle+='materTransparency \"'+AAlpha[i]+'\"\n';
				strHandle+='transformTrans '+AHandleTrans[i]+'\n';
				strHandle+='transformRot '+ AHandleRotate[i]+'\n';
				strHandle+='localrotationtransformRot '+ AHandleLocalRotate[i]+'\n';
				strHandle+='localtransformTrans '+ AHandleLocalTrans[i]+'\n';
				strHandle+='localtransformScale '+ AHandleScale[i]+'\n';
				strHandle+='rolltransformRot '+ AHandleRoll[i]+'\n';
				strHandle+='pitchtransformRot '+ AHandlePitch[i]+'\n';
				strHandle+='yawtransformRot '+ AHandleYaw[i]+'\n';
				strHandle+='}\n';

				handle = Browser.createVrmlFromString(strHandle);							
				addHandle.addChildren = handle;	
		
	 			Browser.addRoute(handle,'TouchID', Browser.getScript(),'TouchID');
		 

			}

			if(ShowHandleFlag){
				GHandleNum = 0;
				AHandleNum = 0;
			}

			deledN = 0;
			//DeledTool = [];
			hidedN = 0;
			//HidedTool = [];

			wholeshape.parents = new MFNode();
			wholegeometry.definition = wholegeometry.definition;
			  

		}
		receivedMessage = '';
	}
	else if (ss == '$BEGIN$')
	{
		receivedMessage = '';
		receiving = true;
	}
	else if (receiving)
	{
		receivedMessage += ss;
	}

	//if (msgUser == Browser.myAvatarName)
	//{
		// The msg lock is obtained, continue send messages if available
		if (sendingMessages.length != 0)
		{
			//sendOneMsg();
			//sendMessage = '';
			sendTimer.enabled = TRUE;
		}
		//else
		//{
			// No message, release the lock
		//	setMsgLock = '';
		//}
	//}

		//resetShape();
		tick();
}

//******************************************************************
//
// Click on screen
//
//******************************************************************

/*function click1()
{
   if(flag1)
   {
	   boundingBox();


}*/


function click()
{
	if(flag1)
	{
		print(touch.hitPoint_changed);
		boundingBox();
		// Show the tool
		print(touch.isActive);
		print(touch.isOver);
		showHideTool = 0;
		//touch.isActive=FALSE;
	
		coordinate = touch.hitPoint_changed;
  		normal = touch.hitNormal_changed;
		//touchSensor = false;
		toolTranslationIn(toolTranslationValue);
		toolRotationIn(toolRotationValue);
		boundingBox();
	}
	else if(!flag1)
	{
	   	// Show the tool
		showHideTool = 0;
	
		coordinate = touch.hitPoint_changed;

	normal = touch.hitNormal_changed;
		//touchSensor = false;
		toolTranslationIn(toolTranslationValue);
		toolRotationIn(toolRotationValue);
	}
}

//******************************************************************
//
// Angles calculation
//
//******************************************************************

function toolRollIn(toolRollIn)
{
	toolRollOut[0] = 0;
	toolRollOut[1] = 0;
	toolRollOut[2] = 1;
	toolRollOut[3] = toolRollIn[3];
}
function toolPitchIn(toolPitchIn)
{
	toolPitchOut[0] = 1;
	toolPitchOut[1] = 0;
	toolPitchOut[2] = 0;
	toolPitchOut[3] = toolPitchIn[3];
}
function toolYawIn(toolYawIn)
{
	toolYawOut[0] = 0;
	toolYawOut[1] = 1;
	toolYawOut[2] = 0;
	toolYawOut[3] = toolYawIn[3];
}
//******************************************************************
//
// Translation calculation
//
//******************************************************************
function toolTranslationIn(toolTranslationIn)
{
	toolTranslationValue = toolTranslationIn;

	toolTranslationOut[0] = coordinate[0] + normal[0] * toolTranslationValue[1];
	toolTranslationOut[1] = coordinate[1] + normal[1] * toolTranslationValue[1];
	toolTranslationOut[2] = coordinate[2] + normal[2] * toolTranslationValue[1];
}
//******************************************************************
//
// Rotation calculation
//
//******************************************************************
function toolRotationIn(toolRotationValue)
{
	if (normal[0] == 0 && normal[1] == 0)
	{
		// When the normal is pointing to the Z axis, no need to rotate
		toolRotationOut[0] = 0;
		toolRotationOut[1] = 0;
		toolRotationOut[2] = 1;
		toolRotationOut[3] = 0;
	}
	else
	{
		var a = new SFVec3f(-normal[1], normal[0], 0);
		a = a.normalize();
		toolRotationOut[0] = a[0];
		toolRotationOut[1] = a[1];
		toolRotationOut[2] = a[2];
		toolRotationOut[3] = Math.acos(normal[2]);
	}
}
//******************************************************************
//
// Scaling calculation
//
//******************************************************************
function toolScaleIn(toolScaleIn)
{
	toolScaleOut[0] = Math.pow(2, toolScaleIn[1]);
	toolScaleOut[1] = Math.pow(2, toolScaleIn[1]);
	toolScaleOut[2] = Math.pow(2, toolScaleIn[1]);
}
//******************************************************************
//
// Move along Y axis
//
//******************************************************************
function toolMoveIn(toolMoveIn)
{
	toolMoveOut[0] = 0;
	toolMoveOut[1] = 0;
	toolMoveOut[2] = toolMoveIn[1];
}



//#--added

//******************************************************************
//
// model transformations calculation
//
//******************************************************************



//function modelTranslationIn(modelTranslationIn){

//	if(moveshapeflag){
//		shapeTranslationOut[0] = modelTranslationIn[1];
//	//	shapeTranslationOut[1] = 0;
//		shapeTranslationOut[2] = 0;
//	}
//	if(moveappearanceflag){
//		appearanceTranslationOut[0] = modelTranslationIn[1];
//		//appearanceTranslationOut[1] =0;
//		appearanceTranslationOut[2] =0;
//	}
//}



function modelScaleIn(modelScaleIn){

	if(moveshapeflag){
		shapeScaleOut[0] = Math.pow(2,modelScaleIn[1]);
		shapeScaleOut[1] = Math.pow(2,modelScaleIn[1]);
		shapeScaleOut[2] = Math.pow(2,modelScaleIn[1]);
	}
	if(moveappearanceflag){
		appearanceScaleOut[0] = Math.pow(2,modelScaleIn[1]);
		appearanceScaleOut[1] = Math.pow(2,modelScaleIn[1]);
		appearanceScaleOut[2] = Math.pow(2,modelScaleIn[1]);
	
	}


}

//#--changed for moveXYZ

function modelMoveIn(modelMoveIn){


	if(moveshapeflag){
//		if(moveXYZ=='1'){
//		   	shapeTranslationOut[0] = shapeTranslationOut[0]+modelMoveIn[0];
//		}
//		else if(moveXYZ=='2'){	shapeTranslationOut[1] = shapeTranslationOut[1]+modelMoveIn[1];}
//		else{	shapeTranslationOut[2] = shapeTranslationOut[2]-modelMoveIn[1];}

	if(moveXYZ=='1'){
		   	shapeTranslationOut[0] = modelMoveIn[0];
		}
		else if(moveXYZ=='2'){	shapeTranslationOut[1] = modelMoveIn[1];}
		else{	shapeTranslationOut[2] = -modelMoveIn[1];}


	}
	if(moveappearanceflag){

//		if(moveXYZ=='1'){
//		   	appearanceTranslationOut[0] = shapeTranslationOut[0]+modelMoveIn[0];
//		}
//		else if(moveXYZ=='2'){	appearanceTranslationOut[1] = shapeTranslationOut[1]+modelMoveIn[1];}
//		else{	appearanceTranslationOut[2] = shapeTranslationOut[2]-modelMoveIn[1];}

		if(moveXYZ=='1'){
		   	appearanceTranslationOut[0] = modelMoveIn[0];
		}
		else if(moveXYZ=='2'){	appearanceTranslationOut[1] = modelMoveIn[1];}
		else{	appearanceTranslationOut[2] = -modelMoveIn[1];}

	
	
	}
  
}
//#!end change


// #--add for rotation-roll-yaw-pitch
//function applyrotate(ori,r){
//	var tag=new Array(3);
//	tag[0] = ori[0]*r[0]+ori[1]*r[4]+ori[2]*r[8]+ori[3]*r[12];
//	tag[1] = ori[0]*r[1]+ori[1]*r[5]+ori[2]*r[9]+ori[3]*r[13];
//	tag[2] = ori[0]*r[2]+ori[1]*r[6]+ori[2]*r[10]+ori[3]*r[14];

//	return tag;

//}

//// #!--end added

function modelRotationIn(modelRotationIn){ //rotation round the y axis



	if(moveshapeflag){
		shapeRotationOut[0] = modelRotationIn[0];
		shapeRotationOut[1] = modelRotationIn[1];
		shapeRotationOut[2] = modelRotationIn[2];
		shapeRotationOut[3] = modelRotationIn[3];
	}
	if(moveappearanceflag){
		appearanceRotationOut[0] = modelRotationIn[0];
		appearanceRotationOut[1] = modelRotationIn[1];
		appearanceRotationOut[2] = modelRotationIn[2];
		appearanceRotationOut[3] = modelRotationIn[3];
	}


}


function modelPitchIn(modelPitchIn){

	if(moveshapeflag){
		shapeRotationOut[0] = 1;
		shapeRotationOut[1] = 0;
		shapeRotationOut[2] = 0;
		shapeRotationOut[3] = modelPitchIn[3];

	}
	if(moveappearanceflag){
	appearanceRotationOut[0] = 1;
	appearanceRotationOut[1] = 0;
	appearanceRotationOut[2] = 0;
	appearanceRotationOut[3] = modelPitchIn[3];
}



}

function modelRollIn(modelRollIn){
	if(moveshapeflag){
		shapeRotationOut[0] = 0;
		shapeRotationOut[1] = 0;
		shapeRotationOut[2] = 1;
		shapeRotationOut[3] = modelRollIn[3];

	}
	if(moveappearanceflag){
	appearanceRotationOut[0] = 0;
	appearanceRotationOut[1] = 0;
	appearanceRotationOut[2] = 1;
	appearanceRotationOut[3] = modelRollIn[3];
}
}

function modelYawIn(modelYawIn){
    if(moveshapeflag){
		shapeRotationOut[0] = 0;
		shapeRotationOut[1] = 1;
		shapeRotationOut[2] = 0;
		shapeRotationOut[3] = modelYawIn[3];

	}
	if(moveappearanceflag){
	appearanceRotationOut[0] = 0;
	appearanceRotationOut[1] = 1;
	appearanceRotationOut[2] = 0;
	appearanceRotationOut[3] = modelYawIn[3];
}

	

}
//#!--end added



//******************************************************************
//
// Apply operation. To send to the network
//
//******************************************************************
function applyOperation()
{
	if (!initialized || (showHideTool == 1 && (operation != 'undo' && operation != 'undocolor')))
	{
		// If the shape is not initialized yet, discard any modifications.
		return;
	}
	//if (lockUser == '')
	//{
		// Competing for the editing lock
		//requestLock = Browser.myAvatarName;
		coord = coordinate;
		nowShape = wholegeometry.definition;
		nowColor = material.diffuseColor;
		editShape();
		
	//}
	showHideTool = 1;
	touchSensor = true;
}
//******************************************************************
//
// Add transformation
//
//******************************************************************
function addTransform(m, a)
{
	var b = new Array(16);
	for(var i=0;i<4;++i)
		for(var j=0;j<4;++j)
		{
			b[i*4+j] = 0;
			for(var k=0;k<4;++k)
			{
				b[i*4+j] += a[i*4+k] * m[k*4+j];
			}
		}
	return b;
}

////////for acceleration///////////
///////transform a vec3f point to new postion by m
function applyTransform(m, a){
	var b = new Array(4);
	var c = new Array(3);
	b[0] = a[0];
	b[1] = a[1];
	b[2] = a[2];
	b[3] = 1;

	c[0] = m[0]*b[0]+m[1]*b[1]+m[2]*b[2]+m[3]*b[3];
    c[1] = m[4]*b[0]+m[5]*b[1]+m[6]*b[2]+m[7]*b[3];
	c[2] = m[8]*b[0]+m[9]*b[1]+m[10]*b[2]+m[11]*b[3];

	return c;


	
}
//******************************************************************
//
// Calculate transformation matrices
//
//******************************************************************
function addTranslation(m, x, y, z)
{
	var a = new Array(16);
	a[0] = 1; a[1] = 0; a[2] = 0; a[3] = x;
	a[4] = 0; a[5] = 1; a[6] = 0; a[7] = y;
	a[8] = 0; a[9] = 0; a[10] = 1; a[11] = z;
	a[12] = 0; a[13] = 0; a[14] = 0; a[15] = 1;
	return addTransform(m, a);
}
function addRotation(m, x, y, z, r)
{
	var c = Math.cos(r);
	var s = Math.sin(r);
	var t = 1 - c;
	var a = new Array(16);

//	#-added changed
//	var dis = sqrt(x*x+y*y+z*z);
//	x = x/dis;
//	y = y/dis;
//	z = z/dis;
//	#!end

	a[0] = t*x*x+c; a[1] = t*x*y-s*z; a[2] = t*x*z+s*y; a[3] = 0;
	a[4] = t*x*y+s*z; a[5] = t*y*y+c; a[6] = t*y*z-s*x; a[7] = 0;
	a[8] = t*x*z-s*y; a[9] = t*y*z+s*x; a[10] = t*z*z+c; a[11] = 0;
	a[12] = 0; a[13] = 0; a[14] = 0; a[15] = 1;

	return addTransform(m, a);
}
function addScale(m, s1,s2,s3)
{
	var a = new Array(16);
	a[0] = s1; a[1] = 0; a[2] = 0; a[3] = 0;
	a[4] = 0; a[5] = s2; a[6] = 0; a[7] = 0;
	a[8] = 0; a[9] = 0; a[10] = s3; a[11] = 0;
	a[12] = 0; a[13] = 0; a[14] = 0; a[15] = 1;
	return addTransform(m, a);
}
//******************************************************************
//
// To keep 5 digita after decimal dot
//
//******************************************************************
function toFix(a)
{
	return Math.round(a*10000)/10000;
}

function HandleDoubleTouched(){
	print('HandleDoubleTouched');


}


function editShape()
{
//******************************************************************
//
// To process commands. Color, undo color, deposit, remove, undo
//
//******************************************************************
	//if(flag1==1)
	//{
	//	boundingBox();
	//	removed=1;
	//}
	
//	var def = nowShape;
//	var cdef = nowColor;
//	var ss = def;
//	var cc = cdef;

	if (operation == 'undo')
	{

	}
	else if (operation == 'color')
	{
		if (toolGeometry.definition.indexOf(';') != -1) return;
		if (material.diffuseColor.indexOf('frep') == -1) return;
	
		//if (cdef.substring(cdef.length - 10, cdef.length) != 'return 0;}') return;


		var alpha = parseFloat(toolMaterial.transparency);

		var greenPos = toolMaterial.diffuseColor.indexOf('g=');
		var bluePos = toolMaterial.diffuseColor.indexOf('b=');

		var redColor = toolMaterial.diffuseColor.substring(2,greenPos-1);
		var greenColor = toolMaterial.diffuseColor.substring(greenPos+2,bluePos-1);
		var blueColor = toolMaterial.diffuseColor.substring(bluePos+2,toolMaterial.diffuseColor.length-1);

		var rrr = parseFloat(redColor);
		var ggg = parseFloat(greenColor);
		var bbb = parseFloat(blueColor);

		var toolColor = new MFFloat(rrr,ggg,bbb);

		AHandleTrans[AHandleNum] = toolTransform.translation;
		AHandleScale[AHandleNum] = toolLocalTransform.scale;
		AHandleRotate[AHandleNum] =	toolTransform.rotation;
		AHandlePitch[AHandleNum] = toolPitchTransform.rotation;
		AHandleYaw[AHandleNum] = toolYawTransform.rotation;
		AHandleRoll[AHandleNum] = toolRollTransform.rotation;
		AHandleLocalRotate[AHandleNum] = toolLocalRotationTransform.rotation;
		AHandleLocalTrans[AHandleNum] = toolLocalTransform.translation;
		
		//AHandleOper[AHandleNum] = operation;

		AHandleDef[AHandleNum] = toolGeometry.definition;
		AColorR[AHandleNum] = toolColor[0];
		AColorG[AHandleNum] = toolColor[1];
		AColorB[AHandleNum] = toolColor[2];
		AAlpha[AHandleNum] = alpha;

		AHandName[AHandleNum] = 'A'+AID;

		var id = 'A'+AID;
	
		var strHandle = '';

		strHandle+= 'DEF '+id+' HandleTool{\n';
		strHandle+='name \"'+id+'\"\n';
		strHandle+='definition \"'+toolGeometry.definition+'\"\n';
		strHandle+='diffusecolor \"'+toolMaterial.diffuseColor+'\"\n';
		strHandle+='materTransparency \"'+toolMaterial.transparency+'\"\n';
		strHandle+='transformTrans '+ toolTransform.translation+'\n';
		strHandle+='transformRot '+ toolTransform.rotation+'\n';
		strHandle+='localrotationtransformRot '+ toolLocalRotationTransform.rotation+'\n';
		strHandle+='localtransformTrans '+ toolLocalTransform.translation+'\n';
		strHandle+='localtransformScale '+ toolLocalTransform.scale+'\n';
		strHandle+='rolltransformRot '+ toolRollTransform.rotation+'\n';
		strHandle+='pitchtransformRot '+ toolPitchTransform.rotation+'\n';
		strHandle+='yawtransformRot '+ toolYawTransform.rotation+'\n';
		strHandle+='}\n';

	
		handle = Browser.createVrmlFromString(strHandle);							
		addHandle.addChildren = handle;	
		
	 	Browser.addRoute(handle,'TouchID', Browser.getScript(),'TouchID');
  		
		AID++;
		AHandleNum++;



	}
	else if (operation == 'undocolor')
	{

		if(AHandleNum>0){ 
			AHandleNum--;

			var v1=0;
			var v2=1;

			tempn1 = addHandle.getSubNodeById('@'+AHandName[AHandleNum]);
			tempn1.setEventIn('dele',v1);
			tempn1.setEventIn('dele',v2);
		}
		
	}

	//#################################################################
	//#--------acceleration found the bounding box of one tool--------#
	//#################################################################

	else  //deposit and remove
	{
		if (toolGeometry.definition.indexOf(';') != -1) return;
	//	if (wholegeometry.definition.indexOf('frep') == -1) return;
		if(geometry.definition.indexOf('frep')==-1) return;

		GHandleTrans[GHandleNum] = toolTransform.translation;
		GHandleRotate[GHandleNum] =	toolTransform.rotation;
		GHandlePitch[GHandleNum] = toolPitchTransform.rotation;
		GHandleYaw[GHandleNum] = toolYawTransform.rotation;
		GHandleRoll[GHandleNum] = toolRollTransform.rotation;
		GHandleLocalRotate[GHandleNum] = toolLocalRotationTransform.rotation;
		GHandleLocalTrans[GHandleNum] = toolLocalTransform.translation;
		GHandleScale[GHandleNum] = toolLocalTransform.scale;
		GHandleOper[GHandleNum] = operation;

		GHandleDef[GHandleNum] = toolGeometry.definition;

		GHandName[GHandleNum] = 'G'+GID;


		///////////updating the tool bounding box  for *acceleration
			GHandleBoxC[GHandleNum] = toolBBoxCenter;
	    	GHandleBoxS[GHandleNum] = toolBBoxSize;
	   
	    
		////////////*acceleration	
		////////////here we add transformation to extend and center of local bounding box, then we can got the AABB
		//var ma = new Array(16);
		//ma[0] = 1; ma[1] = 0; ma[2] = 0; ma[3] = 0;
		//ma[4] = 0; ma[5] = 1; ma[6] = 0; ma[7] = 0;
		//ma[8] = 0; ma[9] = 0; ma[10] = 1; ma[11] = 0;
		//ma[12] = 0; ma[13] = 0; ma[14] = 0; ma[15] = 1;

		//ma = addScale(ma,toolLocalTransform.scale[0],toolLocalTransform.scale[1],toolLocalTransform.scale[2]);
		//GHandleTrans[GHandleNum] = toolTransform.translation;
		//GHandleRotate[GHandleNum] =	toolTransform.rotation;
		//GHandlePitch[GHandleNum] = toolPitchTransform.rotation;
		//GHandleYaw[GHandleNum] = toolYawTransform.rotation;
		//GHandleRoll[GHandleNum] = toolRollTransform.rotation;
		//GHandleLocalRotate[GHandleNum] = toolLocalRotationTransform.rotation;
		//GHandleLocalTrans[GHandleNum] = toolLocalTransform.translation;
		//GHandleScale[GHandleNum] = toolLocalTransform.scale;

		/////ignore local????????????
		//ma = addRotation(ma, toolTransform.rotation[0], toolTransform.rotation[1], toolTransform.rotation[2], toolTransform.rotation[3]);
		//ma = addRotation(ma, toolRollTransform.rotation[0], toolRollTransform.rotation[1], toolRollTransform.rotation[2], toolRollTransform.rotation[3]);
		//ma = addRotation(ma, toolPitchTransform.rotation[0], toolPitchTransform.rotation[1],toolPitchTransform.rotation[2], toolPitchTransform.rotation[3]);
		//ma = addRotation(ma, toolYawTransform.rotation[0], toolYawTransform.rotation[1], toolYawTransform.rotation[2],toolYawTransform.rotation[3]);
		//ma = addTranslation(ma, toolTransform.translation[0], toolTransform.translation[1], toolTransform.translation[2]);
		
		//ma = addRotation(ma, GHandleLocalRotate[i][0], GHandleLocalRotate[i][1], GHandleLocalRotate[i][2], -GHandleLocalRotate[i][3]);
		//ma = addTranslation(ma, -GHandleLocalTrans[i][0], -GHandleLocalTrans[i][1], -GHandleLocalTrans[i][2]);
		
		//var bboxc =  applyTransform(ma,toolBBoxCenter);
		//var bboxs =  applyTransform(ma,toolBBoxSize);
		//GHandleAABBC[GHandleNum][0] = bboxc[0]; 
		//GHandleAABBC[GHandleNum][1] = bboxc[1];
		//GHandleAABBC[GHandleNum][2] = bboxc[2];
		//GHandleAABBS[GHandleNum][0] = bboxs[0];  
		//GHandleAABBS[GHandleNum][1] = bboxs[1];
		//GHandleAABBS[GHandleNum][2] = bboxs[2];

//			m = addTranslation(m, -GHandleTrans[i][0], -GHandleTrans[i][1], -GHandleTrans[i][2]);
//						m = addRotation(m, GHandleRotate[i][0], GHandleRotate[i][1], GHandleRotate[i][2], -GHandleRotate[i][3]);
//						m = addRotation(m, GHandleRoll[i][0], GHandleRoll[i][1], GHandleRoll[i][2], -GHandleRoll[i][3]);
//						m = addRotation(m, GHandlePitch[i][0], GHandlePitch[i][1], GHandlePitch[i][2], -GHandlePitch[i][3]);
//						m = addRotation(m, GHandleYaw[i][0], GHandleYaw[i][1], GHandleYaw[i][2], -GHandleYaw[i][3]);
//						m = addRotation(m, GHandleLocalRotate[i][0], GHandleLocalRotate[i][1], GHandleLocalRotate[i][2], -GHandleLocalRotate[i][3]);
//						m = addTranslation(m, -GHandleLocalTrans[i][0], -GHandleLocalTrans[i][1], -GHandleLocalTrans[i][2]);
//						m = addScale(m,1.0/GHandleScale[i][0],1.0/GHandleScale[i][1],1.0/GHandleScale[i][2]);

		var ma = new Array(16);
		ma[0] = 1; ma[1] = 0; ma[2] = 0; ma[3] = 0;
		ma[4] = 0; ma[5] = 1; ma[6] = 0; ma[7] = 0;
		ma[8] = 0; ma[9] = 0; ma[10] = 1; ma[11] = 0;
		ma[12] = 0; ma[13] = 0; ma[14] = 0; ma[15] = 1;

		ma = addRotation(ma, toolTransform.rotation[0], toolTransform.rotation[1], toolTransform.rotation[2], toolTransform.rotation[3]);
		ma = addRotation(ma, toolRollTransform.rotation[0], toolRollTransform.rotation[1], toolRollTransform.rotation[2], toolRollTransform.rotation[3]);
		ma = addRotation(ma, toolPitchTransform.rotation[0], toolPitchTransform.rotation[1],toolPitchTransform.rotation[2], toolPitchTransform.rotation[3]);
		ma = addRotation(ma, toolYawTransform.rotation[0], toolYawTransform.rotation[1], toolYawTransform.rotation[2],toolYawTransform.rotation[3]);
		ma = addTranslation(ma, toolTransform.translation[0], toolTransform.translation[1], toolTransform.translation[2]);	

		//GHandleAABBC[number] = applyTransform(ma,toolbboxc); 
		//GHandleAABBS[number] = applyTransform(ma, toolbboxs);  
		var bboxc =  applyTransform(ma,toolBBoxCenter);
		
		GHandleAABBC[GHandleNum][0] = bboxc[0]; 
		GHandleAABBC[GHandleNum][1] = bboxc[1];
		GHandleAABBC[GHandleNum][2] = bboxc[2];

		var mb = new Array(16);
		mb[0] = 1; mb[1] = 0; mb[2] = 0; mb[3] = 0;
		mb[4] = 0; mb[5] = 1; mb[6] = 0; mb[7] = 0;
		mb[8] = 0; mb[9] = 0; mb[10] = 1; mb[11] = 0;
		mb[12] = 0; mb[13] = 0; mb[14] = 0; mb[15] = 1;

		mb = addScale(mb,toolLocalTransform.scale[0], toolLocalTransform.scale[1], toolLocalTransform.scale[2]);

		var bboxs =  applyTransform(mb,toolBBoxSize);

		GHandleAABBS[GHandleNum][0] = bboxs[0]; 
		GHandleAABBS[GHandleNum][1] = bboxs[1]; 
		GHandleAABBS[GHandleNum][2] = bboxs[2]; 

 
		var id = 'G'+GID;
	
		var strHandle = '';

	
		strHandle+= 'DEF '+id+' HandleTool{\n';
		strHandle+='name \"'+id+'\"\n';
		strHandle+='definition \"'+toolGeometry.definition+'\"\n';
		//strHandle+='diffusecolor \"'+toolMaterial.diffuseColor+'\"\n';
		//strHandle+='materTransparency \"'+toolMaterial.transparency+'\"\n';
		strHandle+='transformTrans '+ toolTransform.translation+'\n';
		strHandle+='transformRot '+ toolTransform.rotation+'\n';
		strHandle+='localrotationtransformRot '+ toolLocalRotationTransform.rotation+'\n';
		strHandle+='localtransformTrans '+ toolLocalTransform.translation+'\n';
		strHandle+='localtransformScale '+ toolLocalTransform.scale+'\n';
		strHandle+='rolltransformRot '+ toolRollTransform.rotation+'\n';
		strHandle+='pitchtransformRot '+ toolPitchTransform.rotation+'\n';
		strHandle+='yawtransformRot '+ toolYawTransform.rotation+'\n';
		strHandle+='}\n';

		
		handle = Browser.createVrmlFromString(strHandle);							
		addHandle.addChildren = handle;	

 		Browser.addRoute(handle,'TouchID', Browser.getScript(),'TouchID');
 
		GID++;


		GHandleNum++;
			
	}


	tick();

}

//******************************************************************
//
// To ensure that only one user can edit the shape
//
//******************************************************************


//******************************************************************
//
// Short-cut definitions
//
//******************************************************************
function key(ch)
{

	//#---added changed-add the keyflag
	if(keyflag){

	if(ch == 68) { // 'd'
		deposit();
	} else if(ch == 82) { // 'r'
		remove();
	} else if(ch == 67) { // 'c'
		cancel();
	} else if(ch == 84) { // 't'
		rotate();
	} else if(ch == 80) { // 'p'
		displace();
	} else if(ch == 90) { // 'z'
		scale();
	} else if(ch == 85) { // 'u'
		undo();
	} else if(ch == 69) { // 'e'
		resetTool();
		resetCoordinate();
	} else if(ch == 77) { // 'm'
		move();
	} else if(ch == 79) { // 'o'
		applycolor();
	} else if(ch == 78) { // 'n'
		undocolor();
	}else if(ch == 65) { // 'a'
		coordinateSys();
	}else if(ch == 66) { // 'b'
		boundingBox();
	}

}

//#---end change

}
//******************************************************************
//
// To ensure only one user can send message
//
//******************************************************************

//******************************************************************
//
// Called by the left menu
//
//******************************************************************
function texexport(){
	//receiveChat = 'export';
	exportvrml();
}

function texsave(){
	savemodel2();
}

function exportwrl(){
	exportvrml();
}
function savemodel(){
	savemodel2();


}


function remove()
{
	operation = '&(-';
	applyOperation();
}
function deposit()
{
	operation = '|(';
	applyOperation();
}
function undo()
{
	var v1=0;
	var v2=1;
	if(wholemodelflag){
		if(GHandleNum>0){
		GHandleNum--;
	
		tempn1 = addHandle.getSubNodeById('@'+GHandName[GHandleNum]);
		tempn1.setEventIn('dele',v1);
		tempn1.setEventIn('dele',v2);

		tick();

		
	}
}
	else if(moveshapeflag){
	//undo geometry transformation

	if(GeometryArray==1||GeometryArray==0) return;
	else{
	
	GeometryArray = GeometryArray-1;

	shapeRotationOut[0] = GRotation[GeometryArray-1][0];
	shapeRotationOut[1] = GRotation[GeometryArray-1][1];
	shapeRotationOut[2] = GRotation[GeometryArray-1][2];
	shapeRotationOut[3] = GRotation[GeometryArray-1][3];

	shapeTranslationOut[0] = GTranslation[GeometryArray-1][0];
	shapeTranslationOut[1] = GTranslation[GeometryArray-1][1];
	shapeTranslationOut[2] = GTranslation[GeometryArray-1][2];


	shapeScaleOut[0] = GScale[GeometryArray-1][0];
	shapeScaleOut[1] = GScale[GeometryArray-1][1];
	shapeScaleOut[2] = GScale[GeometryArray-1][2];

	pgtrans[0] = GTranslation[GeometryArray][0];
	pgtrans[1] = GTranslation[GeometryArray][1];
	pgtrans[2] = GTranslation[GeometryArray][2];

	GeometryArray = GeometryArray-1;
	
	tick();
}

}
else{
	//undo material transformation

	if(AppearanceArray==1||AppearanceArray==0) return;
	else{
	AppearanceArray = AppearanceArray-1;
		
 	appearanceRotationOut[0] = MRotation[AppearanceArray-1][0];
	appearanceRotationOut[1] = MRotation[AppearanceArray-1][1];
	appearanceRotationOut[2] = MRotation[AppearanceArray-1][2];
	appearanceRotationOut[3] = MRotation[AppearanceArray-1][3];

	appearanceTranslationOut[0] = MTranslation[AppearanceArray-1][0];
	appearanceTranslationOut[1] = MTranslation[AppearanceArray-1][1];
	appearanceTranslationOut[2] = MTranslation[AppearanceArray-1][2];
	
	appearanceScaleOut[0] = MScale[AppearanceArray-1][0];
	appearanceScaleOut[1] = MScale[AppearanceArray-1][1];
	appearanceScaleOut[2] = MScale[AppearanceArray-1][2];


	AppearanceArray = AppearanceArray-1;

	tick();
	

	
}
}


}

function toolUp(){
	

	tempn1 = addHandle.getSubNodeById('@'+toolname);


	tempn1.setEventIn('tooldefinition',tooldefinition);
	tempn1.setEventIn('tooldiffusecolor',toolmaterial);
	tempn1.setEventIn('tooltransparency',toolalpha);
	tempn1.setEventIn('tooltransformTrans',tooltransformTrans);
	tempn1.setEventIn('tooltransformRot',tooltransformRot);
	tempn1.setEventIn('toollocaltransformScale',toollocaltransformScale);
	tempn1.setEventIn('toollocaltransformTrans',toollocaltransformTrans);
	tempn1.setEventIn('toollocalrotationtransformRot',toollocalrotationtransformRot);
	tempn1.setEventIn('toolrolltransformRot',toolrolltransformRot);
	tempn1.setEventIn('toolpitchtransformRot',toolpitchtransformRot);
	tempn1.setEventIn('toolyawtransformRot',toolyawtransformRot);

	tempn1.setEventIn('refresh','TRUE');
	tempn1.setEventIn('refresh','FALSE');

	//for update tool arrays

	

	var number=0;
	
	//if it is an apearance tool
	if(toolname[0]=='A'){
		for(var i=0;i<reservAN;i++){
			if(toolname==AHandName[i]){
			   number = i;
			   break;
			}
		}



	var alpha = parseFloat(toolalpha);

	var greenPos = toolmaterial.indexOf('g=');
	var bluePos = toolmaterial.indexOf('b=');

	var redColor = toolmaterial.substring(2,greenPos-1);
	var greenColor = toolmaterial.substring(greenPos+2,bluePos-1);
	var blueColor = toolmaterial.substring(bluePos+2,toolmaterial.length-1);

	var rrr = parseFloat(redColor);
	var ggg = parseFloat(greenColor);
	var bbb = parseFloat(blueColor);

	var toolColor = new MFFloat(rrr,ggg,bbb);

	AHandleTrans[number] = tooltransformTrans;
	AHandleRotate[number] =	tooltransformRot;
	AHandlePitch[number] = toolpitchtransformRot;
	AHandleYaw[number] = toolyawtransformRot;
	AHandleRoll[number] = toolrolltransformRot;
	AHandleLocalRotate[number] = toollocalrotationtransformRot;
	AHandleLocalTrans[number] = toollocaltransformTrans;
	AHandleScale[number] = toollocaltransformScale;

	AHandleDef[number] = tooldefinition;
	AColorR[number] = toolColor[0];
	AColorG[number] = toolColor[1];
	AColorB[number] = toolColor[2];
	AAlpha[number] = alpha;

//	AHandName[AHandleNum] = 'A'+AID;
	//testing use

	
	}// end of appearance tool

	//it is an geometry tool
	else if(toolname[0]=='G'){
		for(var i=0;i<reservGN;i++){
			if(toolname==GHandName[i]){
			   number = i;

			   break;
			}
		}

	GHandleTrans[number] = tooltransformTrans;
	GHandleRotate[number] =	tooltransformRot;
	GHandlePitch[number] = toolpitchtransformRot;
	GHandleYaw[number] = toolyawtransformRot;
	GHandleRoll[number] = toolrolltransformRot;
	GHandleLocalRotate[number] = toollocalrotationtransformRot;
	GHandleLocalTrans[number] = toollocaltransformTrans;
	GHandleScale[number] = toollocaltransformScale;

	GHandleDef[number] = tooldefinition;

	GHandleBoxC[number] = toolBBoxCenter;
	GHandleBoxS[number] = toolBBoxSize;

	////////////*acceleration	
		////////////here we add transformation to extend and center of local bounding box, then we can got the AABB
		var ma = new Array(16);
		ma[0] = 1; ma[1] = 0; ma[2] = 0; ma[3] = 0;
		ma[4] = 0; ma[5] = 1; ma[6] = 0; ma[7] = 0;
		ma[8] = 0; ma[9] = 0; ma[10] = 1; ma[11] = 0;
		ma[12] = 0; ma[13] = 0; ma[14] = 0; ma[15] = 1;

		ma = addRotation(ma, tooltransformRot[0], tooltransformRot[1], tooltransformRot[2], tooltransformRot[3]);
		ma = addRotation(ma, toolrolltransformRot[0], toolrolltransformRot[1], toolrolltransformRot[2], toolrolltransformRot[3]);
		ma = addRotation(ma, toolpitchtransformRot[0], toolpitchtransformRot[1],toolpitchtransformRot[2], toolpitchtransformRot[3]);
		ma = addRotation(ma, toolyawtransformRot[0], toolyawtransformRot[1], toolyawtransformRot[2],toolyawtransformRot[3]);
		ma = addTranslation(ma, tooltransformTrans[0], tooltransformTrans[1], tooltransformTrans[2]);	

		//GHandleAABBC[number] = applyTransform(ma,toolbboxc); 
		//GHandleAABBS[number] = applyTransform(ma, toolbboxs);  
		var bboxc =  applyTransform(ma,toolBBoxCenter);
		
		GHandleAABBC[number][0] = bboxc[0]; 
		GHandleAABBC[number][1] = bboxc[1];
		GHandleAABBC[number][2] = bboxc[2];

		var mb = new Array(16);
		mb[0] = 1; mb[1] = 0; mb[2] = 0; mb[3] = 0;
		mb[4] = 0; mb[5] = 1; mb[6] = 0; mb[7] = 0;
		mb[8] = 0; mb[9] = 0; mb[10] = 1; mb[11] = 0;
		mb[12] = 0; mb[13] = 0; mb[14] = 0; mb[15] = 1;

		mb = addScale(mb,toollocaltransformScale[0], toollocaltransformScale[1], toollocaltransformScale[2]);

		var bboxs =  applyTransform(mb,toolBBoxSize);

		GHandleAABBS[number][0] = bboxs[0]; 
		GHandleAABBS[number][1] = bboxs[1]; 
		GHandleAABBS[number][2] = bboxs[2]; 

	//testing use

	}//end of geometry tool

//	print(GHandleTrans[number]);
//	print(GHandleRotate[number]);
//	print(GHandlePitch[number]);
//	print(GHandleYaw[number]);
//	print(GHandleRoll[number]);
//	print(GHandleLocalRotate[number]);
//	print(GHandleLocalTrans[number]);
//	print(GHandleScale[number]);
//	print(GHandleDef[number]);

   //tick();

}


function TouchID(s){
	toolname = s.substring(2);


	tempn1 = addHandle.getSubNodeById('@'+toolname);

	if((!HideToolFlag)&&(!DeleToolFlag)){
	
		/*
	tooltransformTrans = tempn1.getField('transformTrans');
	tooltransformRot = tempn1.getField('transformRot');
	toolrolltransformRot = tempn1.getField('rolltransformRot');
	toolpitchtransformRot = tempn1.getField('pitchtransformRot');
	toolyawtransformRot = tempn1.getField('yawtransformRot');
 	toollocaltransformScale = tempn1.getField('localtransformScale');
	toollocaltransformTrans = tempn1.getField('localtransformTrans');
	toollocalrotationtransformRot = tempn1.getField('localrotationtransformRot');
 	tooldefinition = tempn1.getField('definition');
	toolmaterial = tempn1.getField('diffusecolor');
	toolalpha = tempn1.getField('materTransparency');

	//print(toolname);

	var number = parseFloat(toolname.substring(1));

	toolBBoxCenter = GHandleBoxC[number];
	toolBBoxSize = GHandleBoxS[number];

	 var par1 = 'tool'+toolname[0];
	 newurl[0] = 'OnEvent ( ' + par1 + ',' + 'your par2' + ')';
     Browser.loadURL (newurl,param);

		*/
			if(toolname != focusedtool){
		tempn1.setEventIn('focus','0');
		tempn1.setEventIn('focus','1');

	
		if(focusedtool!=''){
	
			
		tempn3 = addHandle.getSubNodeById('@'+focusedtool);
		tempn3.setEventIn('undofocus','0');
		tempn3.setEventIn('undofocus','1');


		
		}

		focusedtool = toolname;	}

		else{
		
		tempn3 = addHandle.getSubNodeById('@'+focusedtool);
		tempn3.setEventIn('undofocus','0');
		tempn3.setEventIn('undofocus','1');

		focusedtool = '';
		}




 }

 else if(HideToolFlag){
	 HidedTool[hidedN] = toolname;
	 hidedN++;
	 tempn1.setEventIn('showSwitch','1');
 }
 else if(DeleToolFlag){
	 DeledTool[deledN] = toolname;
	 deledN++;
	 tempn1.setEventIn('dele','0');
	 tempn1.setEventIn('dele','1');

 }
 }


 function EditTool(t){
	//toolname = s.substring(2);

	 print(t);
	 print(focusedtool);

	tempn1 = addHandle.getSubNodeById('@'+focusedtool);

	
		
	tooltransformTrans = tempn1.getField('transformTrans');
	tooltransformRot = tempn1.getField('transformRot');
	toolrolltransformRot = tempn1.getField('rolltransformRot');
	toolpitchtransformRot = tempn1.getField('pitchtransformRot');
	toolyawtransformRot = tempn1.getField('yawtransformRot');
 	toollocaltransformScale = tempn1.getField('localtransformScale');
	toollocaltransformTrans = tempn1.getField('localtransformTrans');
	toollocalrotationtransformRot = tempn1.getField('localrotationtransformRot');
 	tooldefinition = tempn1.getField('definition');
	toolmaterial = tempn1.getField('diffusecolor');
	toolalpha = tempn1.getField('materTransparency');

	//print(toolname);

	var number = parseFloat(toolname.substring(1));

	toolBBoxCenter = GHandleBoxC[number];
	toolBBoxSize = GHandleBoxS[number];

	 //var par1 = 'tool'+toolname[0];
	 //newurl[0] = 'OnEvent ( ' + par1 + ',' + 'your par2' + ')';
    // Browser.loadURL (newurl,param);

		
 }

function edit (value, time) { 
     newurl[0] = 'OnEvent ( ' + moveshapeflag + ',' + 'your par2' + ')';
     Browser.loadURL (newurl,param);
   } 

   function refreshform (time) {
	   //var refreshurl = 'refresh ( par1, par2 )';
	   refreshurl[0] = 'OnEvent ( ' + 'refresh ' + ',' + 'your par2' + ')';
	   Browser.loadURL(refreshurl,param);
   }

   function load(time){
	   refreshurl[0] = 'OnEvent ( ' + 'load ' + ',' + 'your par2' + ')';
	   Browser.loadURL(refreshurl,param);
   }
   function savemodel2(){

//	   	var par2 = '-------------Save Start--------------\n'+'`' 
//			+ wholegeometry.definition + '`' + wholematerial.diffuseColor + '`' + assembleVec3f(wholegeometry.bboxCenter)
//			   + '`' + assembleVec3f(wholegeometry.bboxSize) + '`' + assembleFloatArray(wholegeometry.resolution)
//			   + '`' + assembleFloatArray(wholegeometry.parameters) + '`' + assembleColorArray(wholematerial.patternColor)
//			   + '`' + assembleFloatArray(wholematerial.patternKey) + '`' + wholeshape.polygonizer  + '`' + wholeshape.cycleInterval
//			   + '`' + assembleVec2f(wholematerial.timeSpan) + '`' + wholetexture.definition + '`' + assembleVec2f(wholetexture.timeSpan)
//			   + '`' + assembleVec2f(wholegeometry.timeSpan) + '`'+'\n--------------Save End---------------';
	   //assembleVec3f
	   //assembleVec2f
	   //assembleFloatArray
	   //assembleColorArray
	   //assembleSFRotation
	   //assembleMFString
	   //assembleVec3fArray
	   //assembleSFRotationArray
	   //

			

			var par2 = '-------------Save Start-------------- \n'
			+ '`'+ shape.geoDef
			+ '`'+ assembleVec3f(shape.gtranslation)
			+ '`'+ assembleSFRotation(shape.grotation)
			+ '`'+ assembleVec3f(shape.gscale)
			+ '`' + assembleVec3f(wholegeometry.bboxCenter)
			+ '`' + assembleVec3f(wholegeometry.bboxSize) 
			+ '`' + assembleFloatArray(wholegeometry.resolution)
			+ '`' + assembleFloatArray(wholegeometry.parameters) 
			+ '`' + assembleColorArray(wholematerial.patternColor)
			+ '`' + assembleFloatArray(wholematerial.patternKey) 
			+ '`' + wholematerial.transparency
			+ '`' + wholematerial.emissiveColor
			+ '`' + wholematerial.ambientIntensity
			+ '`' + wholematerial.specularColor
			+ '`' + wholematerial.shininess
			+ '`' + wholematerial.type

			+ '`' + wholeshape.polygonizer  
			+ '`' + wholeshape.cycleInterval
			+ '`' + wholeshape.loop
			+ '`' + assembleVec2f(wholematerial.timeSpan) 
			//+ ''
			+ '`' + wholetexture.definition 
			+ '`' + assembleVec2f(wholetexture.timeSpan)
			+ '`' + assembleVec2f(wholegeometry.timeSpan) 
			+ '`' + shape.difusecolorDef
			+ '`' + assembleVec3f(shape.atranslation)
			+ '`' + assembleSFRotation(shape.arotation)
			+ '`' + assembleVec3f(shape.ascale)
			+ '`' + GHandleNum
			+ '`'+ assembleMFString(GHandleDef,GHandleNum) 
			+ '`'+ assembleVec3fArray(GHandleTrans,GHandleNum)
			+ '`'+ assembleSFRotationArray(GHandleRotate,GHandleNum) 
			+ '`'+ assembleVec3fArray(GHandleScale,GHandleNum) 
			+ '`'+ assembleSFRotationArray(GHandleYaw,GHandleNum)
			+ '`'+ assembleSFRotationArray(GHandlePitch,GHandleNum) 
			+ '`'+ assembleSFRotationArray(GHandleRoll,GHandleNum)   
			+ '`'+ assembleSFRotationArray(GHandleLocalRotate,GHandleNum) 
			+ '`'+ assembleVec3fArray(GHandleLocalTrans,GHandleNum)
			+ '`'+ assembleMFString(GHandleOper,GHandleNum) 
			+ '`'+ AHandleNum
			+ '`'+ assembleMFString(AHandleDef,AHandleNum) 
			+ '`'+ assembleVec3fArray(AHandleTrans,AHandleNum)
			+ '`'+ assembleSFRotationArray(AHandleRotate,AHandleNum)
			+ '`'+ assembleVec3fArray(AHandleScale,AHandleNum) 
			+ '`'+ assembleSFRotationArray(AHandleYaw,AHandleNum)
			+ '`'+ assembleSFRotationArray(AHandlePitch,AHandleNum)
			+ '`'+ assembleSFRotationArray(AHandleRoll,AHandleNum)  
			+ '`'+ assembleSFRotationArray(AHandleLocalRotate,AHandleNum)
			+ '`'+ assembleVec3fArray(AHandleLocalTrans,AHandleNum)
			+ '`'+ assembleFloatArray(AColorR,AHandleNum)
			+ '`'+ assembleFloatArray(AColorG,AHandleNum)
		    + '`'+ assembleFloatArray(AColorB,AHandleNum)
			+ '`'+ assembleFloatArray(AAlpha,AHandleNum)
			+ '`'+'\n--------------Save End---------------';
		
	    refreshurl[0] = 'OnEvent ( ' + 'save ' + ',' + par2 + ')';
	   Browser.loadURL(refreshurl,param);

   }
   function exportvrml(){
	
			var par2 = '';
			par2 += 'FShape {\n';
			par2 += 'polygonizer \"' + wholeshape.polygonizer + '\"\n';
			par2 += '	loop ' + wholeshape.loop +'\n';
			par2 += '	cycleInterval ' + wholeshape.cycleInterval+'\n';
			par2 += '	appearance FAppearance {'+'\n';
			par2 += '		material FMaterial {'+'\n';
			par2 += '			diffuseColor \"' + wholematerial.diffuseColor + '\"'+'\n';
			par2 += '			patternKey ' + wholematerial.patternKey+'\n';
			par2 += '			patternColor ' + wholematerial.patternColor+'\n';
			par2 += '			timeSpan ' + wholematerial.timeSpan+'\n';
			par2 += '			transparency \"'+wholematerial.transparency+'\"\n';
			par2 += '			emissiveColor \"'+wholematerial.emissiveColor+'\"\n';
			par2 += '			ambientIntensity \"'+wholematerial.ambientIntensity +'\"\n';
			par2 += '			specularColor \"'+wholematerial.specularColor +'\"\n';
			par2 += '			shininess \"'+wholematerial.shininess +'\"\n';
			par2 += '			type \"'+wholematerial.type +'\"\n';
			par2 += '		}'+'\n';
			par2 += '		texture3D FTexture3D {'+'\n';
			par2 += '			definition \"' + wholetexture.definition + '\"'+'\n';
			par2 += '			timeSpan ' + wholetexture.timeSpan+'\n';
			par2 += '         type \"displacement\"'+'\n';
			par2 += '		}'+'\n';
			par2 += '	}'+'\n';
			par2 += '	geometry FGeometry {'+'\n';
			par2 += '		definition \"' + wholegeometry.definition + '\"'+'\n';
			par2 += '		parameters ' + wholegeometry.parameters+'\n';
			par2 += '		bboxSize ' + wholegeometry.bboxSize+'\n';
			par2 += '		bboxCenter ' + wholegeometry.bboxCenter+'\n';
			par2 += '		resolution ' + wholegeometry.resolution+'\n';
			par2 += '		timeSpan ' + wholegeometry.timeSpan+'\n';
			par2 += '	}'+'\n';
			par2 += '}'+'\n';
	   
		refreshurl[0] = 'OnEvent ( ' + 'export ' + ',' + par2 + ')';
		Browser.loadURL(refreshurl,param);
   }


function undocolor()
{
	operation = 'undocolor';
	applyOperation();
}
function applycolor()
{
	operation = 'color';
	applyOperation();
}
function cancel()
{
	showHideTool = 1;
	touchSensor = true;
}
function boundingBox()
{

	
	if(!flag1)
	{
		var temp = new SFVec3f(wholegeometry.bboxSize);
		for(var i=0;i<3;++i)
		{
			dd[i] = parseFloat(temp[i]);
		}
		var temps = new SFVec3f(wholegeometry.bboxCenter);
		
		//var dds = new MFFLoat();
		//print(temp);
		//print(temps);
		for(var j=0;j<3;++j)
		{
			dds[j] = parseFloat(temps[j]);
		}
		str1+='Transform { ';
		//str1+='translation 1 1 1  ';
		str1+='translation '+dds[0]+' '+dds[1]+' '+dds[2]+'   ';
		str1+='children [  ';
		str1+='Shape {' ;
		str1+='appearance Appearance {';
		str1+='material Material {';
		str1+='diffuseColor .3 .3 0.8  ';
		str1+='emissiveColor .1 .1 .33  ';
		str1+='transparency 0.8 }} ';
		str1+='geometry Box { ';
		//str1+='size 2.5 2.5 2.5  }}';
		str1+='size '+dd[0]+' '+dd[1]+' '+dd[2]+'  }}]}';
		
		tempNode1 = Browser.createVrmlFromString(str1);

		//#--changed
		//model.addChildren = tempNode1;
		addedObject.addChildren = tempNode1;

		//#!--end changed

		//Browser.createVrmlFromURL(address, addedObject, event);
		//Browser.createVrmlFromURL('CoordinateAxes.wrl', tempNode);
		flag1=TRUE;
		BoundingBox.color='1 0 0';
	}
	else if(flag1)
	{
		//#--changed
		//model.removeChildren = tempNode1;
		addedObject.removeChildren=tempNode1;
		//#!--end changed

		flag1=FALSE;
		str1='';
		BoundingBox.color='0.8 0.4 1';
	}



}

function boundingBox1()
{
	if(!flag1)
	{
		var temp = new SFVec3f(wholegeometry.bboxSize);
		for(var i=0;i<3;++i)
		{
			dd[i] = parseFloat(temp[i]);
		}
		var temps = new SFVec3f(wholegeometry.bboxCenter);
		
		for(var j=0;j<3;++j)
		{
			dds[j] = parseFloat(temps[j]);
		}
		str1+='Transform { ';
		//str1+='translation 1 1 1  ';
		str1+='translation '+dds[0]+' '+dds[1]+' '+dds[2]+'   ';
		str1+='children [  ';
		str1+='Shape {' ;
		str1+='appearance Appearance {';
		str1+='material Material {';
		str1+='diffuseColor .3 .3 0.8  ';
		str1+='emissiveColor .1 .1 .33  ';
		str1+='transparency 0.8 }} ';
		str1+='geometry Box { ';
		//str1+='size 2.5 2.5 2.5  }}';
		str1+='size '+dd[0]+' '+dd[1]+' '+dd[2]+'  }}]}';
		
		tempNode1 = Browser.createVrmlFromString(str1);
		//#--changed
		//model.addChildren = tempNode1;
		addedObject.addChildren = tempNode1;

		//#!--end changed

		//Browser.createVrmlFromURL(address, addedObject, event);
		//Browser.createVrmlFromURL('CoordinateAxes.wrl', tempNode);
		flag1=TRUE;
		
	}
	else if(flag1)
	{
		//#--changed
		//model.removeChildren = tempNode1;
		addedObject.removeChildren=tempNode1;
		//#!--end changed
		flag1=FALSE;
		str1='';
		
	}
}

function bbox2(){
   boundingBox1();
   boundingBox1();
}

function coordinateSys()
{
   	if(wholemodelflag){
	geometrycoord=1;  //disable geometrycoordinate
	appearancecoord = 1;//disable appearancecoord
   
  }
  else if(moveshapeflag){
	appearancecoord = 1; //disable appearancecoord
	geometrycoord=0;
	}
	else{
	geometrycoord=1;  //disable geometrycoordinate
	appearancecoord = 0;
	
}

	tempNode = Browser.createVrmlFromString(str);

	if(showShapeCoord)
	{

	//	addedObject.addChildren = tempNode;
	//	flag=TRUE;
		showShapeCoord = 0;
		CoordinateSys.color='1 0 0';
	}
	else if(!showShapeCoord)
	{
	//	addedObject.removeChildren = tempNode;
	//	flag=FALSE;
		showShapeCoord = 1;
		CoordinateSys.color='0.8 0.4 1';
	}
	
}

function ShowHandleIn(){
	if(ShowHandleFlag){	//turn off
		ShowHandleOut = 1;
	//	wholemodelswitch = 0;
		ShowHandleColor = '0.8 0.4 1';
		showOp = reservChoice;
		touch.enabled = true;

		AHandleNum = reservAN;
		GHandleNum = reservGN;

		 newurl[0] = 'OnEvent ( toolclose,' + 'your par2' + ')';
    	 Browser.loadURL (newurl,param);

		 if(focusedtool!=''){
		tempn3 = addHandle.getSubNodeById('@'+focusedtool);
		tempn3.setEventIn('undofocus','0');
		tempn3.setEventIn('undofocus','1');

		focusedtool = '';
	} 

	}
	else{
		ShowHandleOut = 0;
		ShowHandleColor = '1 0 0';
		reservChoice = showOp;
		showOp = 2;
	//	wholemodelswitch = 1;
		touch.enabled = false;

		reservAN = AHandleNum;
		reservGN = GHandleNum;
		AHandleNum = 0;
		GHandleNum = 0;

		HideToolFlag = false;
		DeleToolFlag = false;
		DeleToolColor = '0.8 0.4 1';
		HideToolColor = '0.8 0.4 1';

		ShowAllIn();
	}

	ShowHandleFlag = !ShowHandleFlag;
	tick();
}

function HideToolIn(){
	if(HideToolFlag){	//turn off
		HideToolColor = '0.8 0.4 1';
		
	}
	else{
		HideToolColor = '1 0 0';

		DeleToolColor = '0.8 0.4 1';
		DeleToolFlag = false;
		
	}

	HideToolFlag = !HideToolFlag;
//	tick();
}

function UndoHideIn(){

	if(hidedN>0){
		hidedN--;
		tempn1 = addHandle.getSubNodeById('@'+HidedTool[hidedN]);
	
	  tempn1.setEventIn('showSwitch','0');
  }
}

function DeleToolIn(){
	if(DeleToolFlag){	//turn off
		DeleToolColor = '0.8 0.4 1';

		
	}
	else{
		DeleToolColor = '1 0 0';
		HideToolColor = '0.8 0.4 1';
		HideToolFlag = false;
		
	}

	DeleToolFlag = !DeleToolFlag;
}

function UndoDeleIn(){

	if(deledN>0){
		deledN--;
		tempn1 = addHandle.getSubNodeById('@'+DeledTool[deledN]);
	
	  tempn1.setEventIn('undoDele','0');
	  tempn1.setEventIn('undoDele','1');
  }
}

function ShowAllIn(){

	for(;hidedN>0;){
		hidedN--;
		tempn1 = addHandle.getSubNodeById('@'+HidedTool[hidedN]);
	    tempn1.setEventIn('showSwitch','0');
		HidedTool[hidedN] = '';
  }
}
//#--added
function moveableShape(){
	touch.enabled = false;
	MoveableShape.color = '1 0 0';
	MoveableAppearance.color = '0.8 0.4 1';
	WholeModelT.color = '0.8 0.4 1';
	moveshapeflag = true;
	moveappearanceflag = false;
	wholemodelflag = false;
	
	showModel = 0;
	showOp = 1;

	//#--added shapecoord
	//showShapeCoord = 1;

	appearancecoord = 1;
	coordgeometryflag = 1;

 	geometrycoord = 0;

//	addedObject.removeChildren = tempNode1;

//	appearancebox=1;

	//#--added shapecoord
	//showShapeCoord = 0;

	//#--added 
	toolDisplaceSensor = false;
	toolRotateSensor = false;
	toolScaleSensor = false;
	toolMoveSensor = false;
	toolRollSensor = false;
	toolPitchSensor = false;
	toolYawSensor = false;

	modelDisplaceSensor = false;
	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = false;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = false;

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);
}

function moveableAppearance(){
	touch.enabled = false;
	MoveableAppearance.color = '0 1 0';
	MoveableShape.color = '0.8 0.4 1';
	WholeModelT.color = '0.8 0.4 1';

	moveappearanceflag = true;
	moveshapeflag = false;
	wholemodelflag = false;

	showModel = 0;
	showOp = 1;

	//#--added shapecoord
//	showShapeCoord = 1;

	geometrycoord = 1;
	coordappearanceflag = 1;
//	if(showShapeCoord)	CoordinateSys.color = '0.8 0.4 1';
//	else CoordinateSys.color = '1 0 0';

	appearancecoord = 0;


	toolDisplaceSensor = false;
	toolRotateSensor = false;
	toolScaleSensor = false;
	toolMoveSensor = false;
	toolRollSensor = false;
	toolPitchSensor = false;
	toolYawSensor = false;

	modelDisplaceSensor = false;
	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = false;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = false;

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);


	
}

function wholeModelT(){

	touch.enabled = true;
	WholeModelT.color = '1 1 0';
	MoveableAppearance.color = '0.8 0.4 1';
	MoveableShape.color = '0.8 0.4 1';

	moveshapeflag = false;
	moveappearanceflag = false;
	wholemodelflag = true;

	editColor();

	showModel = 1;
	showOp = 0;


	toolDisplaceSensor = false;
	toolRotateSensor = false;
	toolScaleSensor = false;
	toolMoveSensor = false;
	toolRollSensor = false;
	toolPitchSensor = false;
	toolYawSensor = false;

	modelDisplaceSensor = false;
	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = false;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = false;

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);

}

function starStack(){

}

function editColor(){

		if (!initialized )
	{
		// If the shape is not initialized yet, discard any modifications.
		return;
	}

//		coord = coordinate;
	
	//var	materialColor = material.diffuseColor;
	var materialColor = shape.difusecolorDef;
	var wholeColor = wholematerial.diffuseColor;
	
	var colorFunc = '';
	var mainColor='';
	var painting='';

	var cc='';

	var m = new Array(16);

	
	if(wholematerial.diffuseColor.indexOf('frep')==-1) return;

	m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
	m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
	m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
	m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;

//	m = addRotation(m,shape.grotation [0],shape.grotation [1],shape.grotation [2],shape.grotation [3]);
//	m = addScale(m,shape.gscale[0],shape.gscale[1],shape.gscale[2]);
	

//	m = addTranslation(m,shape.gtranslation[0],shape.gtranslation[1],shape.gtranslation[2]);
	m = addTranslation(m,-shape.atranslation[0],-shape.atranslation[1],-shape.atranslation[2]);
	m = addScale(m,1/shape.ascale[0],1/shape.ascale[1],1/shape.ascale[2]);
	m = addRotation(m,shape.arotation [0],shape.arotation [1],shape.arotation [2],-shape.arotation [3]);



	if((materialColor.indexOf('r=')==-1)&&(materialColor.indexOf('g=')==-1)&&(materialColor.indexOf('b=')==-1)){
	colorFunc += 'x=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
	colorFunc += 'y=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
	colorFunc += 'z=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
}
	else{
		colorFunc += 'u=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
		colorFunc += 'v=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
		colorFunc += 'w=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
	}

	mainColor =  colorFunc+materialColor;

		for(var i=0;i<AHandleNum;i++){

		var deled = 0;
		for(var j=0;j<deledN;j++){
			if(DeledTool[j]==AHandName[i]) deled = 1;
		}

		if(!deled){
		m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
		m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
		m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
		m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;

		//tempTranslation[0] = 
		m = addTranslation(m, -AHandleTrans[i][0], -AHandleTrans[i][1], -AHandleTrans[i][2]);
		m = addRotation(m, AHandleRotate[i][0], AHandleRotate[i][1], AHandleRotate[i][2], -AHandleRotate[i][3]);
		m = addRotation(m, AHandleRoll[i][0], AHandleRoll[i][1], AHandleRoll[i][2], -AHandleRoll[i][3]);
		m = addRotation(m, AHandlePitch[i][0], AHandlePitch[i][1], AHandlePitch[i][2], -AHandlePitch[i][3]);
		m = addRotation(m, AHandleYaw[i][0], AHandleYaw[i][1], AHandleYaw[i][2], -AHandleYaw[i][3]);
		m = addRotation(m, AHandleLocalRotate[i][0], AHandleLocalRotate[i][1], AHandleLocalRotate[i][2], -AHandleLocalRotate[i][3]);
		m = addTranslation(m, -AHandleLocalTrans[i][0], -AHandleLocalTrans[i][1], -AHandleLocalTrans[i][2]);
		m = addScale(m,1.0/AHandleScale[i][0],1.0/AHandleScale[i][1],1.0/AHandleScale[i][2]);

		painting += 'x=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
		painting += 'y=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
		painting += 'z=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
		
		painting += 'if(' + AHandleDef[i] + '>=0){r=r*' + toFix(AAlpha[i]) + '+' + toFix(AColorR[i]) + '*' + toFix(1-AAlpha[i])
		   + ';g=g*' + toFix(AAlpha[i]) + '+' + toFix(AColorG[i]) + '*' + toFix(1-AAlpha[i])
		   + ';b=b*' + toFix(AAlpha[i]) + '+' + toFix(AColorB[i]) + '*' + toFix(1-AAlpha[i]) + ';}\\n';
   }

	}

	 
	//colorFunc += materialColor.substring(43,materialColor.length);
	cc = 'function frep(x1,y1,z1,t){\\n'+mainColor+'\\n'+painting+'return 0;}';

//		geodefinitionFunc = geodefinitionFunc+Geometry+'\\nreturn fun;}';

//	cc = 'function frep(x1,y1,z1,t){\\n'+geodefinitionFunc;

	if(cc != wholeColor)
	{
	//	if(AppearanceArray==9){}
	wholeColor = cc;

	//print(cc);

	wholematerial.diffuseColor = wholeColor;

	MRotation[AppearanceArray] = shape.arotation;
	MTranslation[AppearanceArray] = shape.atranslation;
	MScale[AppearanceArray] = shape.ascale;

	AppearanceArray=AppearanceArray+1;

//	print(AppearanceArray);
//	print(MRotation);
//	print(MTranslation);
//	print(MScale);

	}


}

//function editGeometry(){
//		if (!initialized )
//	{
//		// If the shape is not initialized yet, discard any modifications.
//		return;
//	}

//	var	geometryDefinition = wholegeometry.definition;
//	//var Geometry = geometry.definition;
//	var Geometry = shape.geoDef;
//	var geodefinitionFunc = '';

//	var mainshape = '';
//	var toolgroup = '';


//	//###############################################################
// 	//#-------------------acceleration script-----------------------#
//	//###############################################################
	
	

//	///////////////following is new scripting////////////////////////
	
	
//    //send GhandleBox-------
//	var parameter1 = 'VOTree';
//	boxlist = '';
//	//boxlist = '#0I'+ wholegeometry.bboxCenter[0]+' '+ wholegeometry.bboxCenter[1]+' '+wholegeometry.bboxCenter[2]+' '+wholegeometry.bboxSize[0]+' '+wholegeometry.bboxSize[1]+' '+wholegeometry.bboxSize[2];
//	boxlist = '#-1I'+ shape.geometry.bboxCenter[0]+' '+ shape.geometry.bboxCenter[1]+' '+shape.geometry.bboxCenter[2]+' '+shape.geometry.bboxSize[0]+' '+shape.geometry.bboxSize[1]+' '+shape.geometry.bboxSize[2];
	
//	//var par2 = '';
//	for(var i=0; i<GHandleNum;i++){

//			var deled = 0;
//						for(var j=0;j<deledN;j++){
//						if(DeledTool[j]==GHandName[i]) deled = 1;
//						}

//						if(!deled){
//		//if(i==0) par2 = par2+GHandleName[i]+'&'+GHandleBoxC[i][0]+' '+GHandleBoxC[i][1]+' '+GHandleBoxC[i][2]+' '+GHandleBoxS[i][0]+' '+GHandleBoxS[i][1]+' '+GHandleBoxS[i][2]; 
		
//		//boxlist = boxlist+'#'+GHandName[i]+'I'+GHandleAABBC[i][0]+' '+GHandleAABBC[i][1]+' '+GHandleAABBC[i][2]+' '+GHandleAABBS[i][0]+' '+GHandleAABBS[i][1]+' '+GHandleAABBS[i][2]; 
//		//id use GhandNum, because it is used fro editing the script
//		 boxlist = boxlist+'#'+i+'I'+GHandleAABBC[i][0]+' '+GHandleAABBC[i][1]+' '+GHandleAABBC[i][2]+' '+GHandleAABBS[i][0]+' '+GHandleAABBS[i][1]+' '+GHandleAABBS[i][2]; 
		
//		//boxlist = boxlist+'#'+GHandName[i]+'I'+GHandleBoxC[i][0]+' '+GHandleBoxC[i][1]+' '+GHandleBoxC[i][2]+' '+GHandleBoxS[i][0]+' '+GHandleBoxS[i][1]+' '+GHandleBoxS[i][2];
//	 }
// }

//    newurl[0] = 'OnEvent ( ' + parameter1 + ',' + 'your par2' + ')';
//    Browser.loadURL (newurl,param);

//	//print(VOTree);
//	var trees =  VOTree;
//	//print(VOTree)+'\\n';

	
//	if(GHandleNum>5){
//	var subs = '';
//	var subss;
//	var idx1 = 0;

//	var m = new Array(16);

//	m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
//	m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
//	m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
//	m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;

	

//	var cx,cy,cz,sx,sy,sz;
	
//	if(Geometry.indexOf('fun')!=-1){ // for implicitly defined shapes-----do this

//		m = addTranslation(m,-shape.gtranslation[0],-shape.gtranslation[1],-shape.gtranslation[2]);
//		m = addRotation(m,shape.grotation [0],shape.grotation [1],shape.grotation [2],-shape.grotation [3]);
//		m = addScale(m,1/shape.gscale[0],1/shape.gscale[1],1/shape.gscale[2]);

////	if((Geometry.indexOf('x=')==-1)&&(Geometry.indexOf('y=')==-1)&&(Geometry.indexOf('z=')==-1)){
//		mainshape += 'x=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
//		mainshape += 'y=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
//		mainshape += 'z=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');';
////}
////	else{
////		mainshape += 'u=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
////		mainshape += 'v=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
////		mainshape += 'w=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
////	}


//		mainshape += Geometry+'\\n';


//		var ma = new Array(16);
//		var mb = new Array(16);

//		//idx1 = trees.indexOf('L');
//		while(trees!=''){

//			if(trees[0]=='L'){
//				idx2 = trees.indexOf('[');
//				subs = trees.substring(1,idx2);
//				subss = split(subs,' ');
//				cx = toFix(parseFloat(subss[0]));
//				cy = toFix(parseFloat(subss[1]));
//				cz = toFix(parseFloat(subss[2]));
//				sx = toFix(parseFloat(subss[3])/2);
//				sy = toFix(parseFloat(subss[4])/2);
//				sz = toFix(parseFloat(subss[5])/2);

//				ma[0] = 1; ma[1] = 0; ma[2] = 0; ma[3] = 0;
//				ma[4] = 0; ma[5] = 1; ma[6] = 0; ma[7] = 0;
//				ma[8] = 0; ma[9] = 0; ma[10] = 1; ma[11] = 0;
//				ma[12] = 0; ma[13] = 0; ma[14] = 0; ma[15] = 1;
					
//				ma = addTranslation(ma,shape.gtranslation[0],shape.gtranslation[1],shape.gtranslation[2]);
//				//ma = addRotation(ma,shape.grotation [0],shape.grotation [1],shape.grotation [2],shape.grotation [3]);	
//				//ma = addScale(ma,shape.gscale[0],shape.gscale[1],shape.gscale[2]);
			   
//				var boxc = new SFVec3f(cx, cy, cz);

//				boxc =  applyTransform(ma,boxc);
//				//var bboxcs = split(bboxc,' ');
//				cx = boxc[0];
//				cy = boxc[1];
//				cz = boxc[2];


//			toolgroup += 'if(abs(x1-('+cx+'))<'+sx+'&&abs(y1-('+cy+'))<'+sy+'&&abs(z1-('+cz+'))<'+sz+'){\\n';

//			trees = trees.substring(idx2+1);
//			}
//			else if(trees[0]=='('){
//				idx2 = trees.indexOf(')');
//				subs = trees.substring(1,idx2);
//				subss = split(subs,' ');
//				id = subss[0];
//				cx = toFix(parseFloat(subss[1]));
//				cy = toFix(parseFloat(subss[2]));
//				cz = toFix(parseFloat(subss[3]));
//				sx = toFix(parseFloat(subss[4])/2);
//				sy = toFix(parseFloat(subss[5])/2);
//				sz = toFix(parseFloat(subss[6])/2);


//				ma[0] = 1; ma[1] = 0; ma[2] = 0; ma[3] = 0;
//				ma[4] = 0; ma[5] = 1; ma[6] = 0; ma[7] = 0;
//				ma[8] = 0; ma[9] = 0; ma[10] = 1; ma[11] = 0;
//				ma[12] = 0; ma[13] = 0; ma[14] = 0; ma[15] = 1;
					
//				ma = addTranslation(ma,shape.gtranslation[0],shape.gtranslation[1],shape.gtranslation[2]);
//				//ma = addRotation(ma,shape.grotation[0],shape.grotation[1],shape.grotation[2],shape.grotation[3]);
//		    	//ma = addScale(ma,shape.gscale[0],shape.gscale[1],shape.gscale[2]);	

				
//				var boxc = new SFVec3f(cx, cy, cz);

//				boxc =  applyTransform(ma,boxc);
//				//var bboxcs = split(bboxc,' ');
//				cx = boxc[0];
//				cy = boxc[1];
//				cz = boxc[2];


//				toolgroup += 'if(abs(x1-('+cx+'))<'+sx+'&&abs(y1-('+cy+'))<'+sy+'&&abs(z1-('+cz+'))<'+sz+'){\\n';

//				if(id!=-1){
//						var i =parseInt(id);
					
					 
//						m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
//						m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
//						m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
//						m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;
				
//						//tempTranslation[0] = 
//						m = addTranslation(m, -GHandleTrans[i][0], -GHandleTrans[i][1], -GHandleTrans[i][2]);
//						m = addRotation(m, GHandleRotate[i][0], GHandleRotate[i][1], GHandleRotate[i][2], -GHandleRotate[i][3]);
//						m = addRotation(m, GHandleRoll[i][0], GHandleRoll[i][1], GHandleRoll[i][2], -GHandleRoll[i][3]);
//						m = addRotation(m, GHandlePitch[i][0], GHandlePitch[i][1], GHandlePitch[i][2], -GHandlePitch[i][3]);
//						m = addRotation(m, GHandleYaw[i][0], GHandleYaw[i][1], GHandleYaw[i][2], -GHandleYaw[i][3]);
//						m = addRotation(m, GHandleLocalRotate[i][0], GHandleLocalRotate[i][1], GHandleLocalRotate[i][2], -GHandleLocalRotate[i][3]);
//						m = addTranslation(m, -GHandleLocalTrans[i][0], -GHandleLocalTrans[i][1], -GHandleLocalTrans[i][2]);
//						m = addScale(m,1.0/GHandleScale[i][0],1.0/GHandleScale[i][1],1.0/GHandleScale[i][2]);

//						toolgroup += 'x=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
//						toolgroup += 'y=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
//						toolgroup += 'z=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
		
//						toolgroup += 'fun=fun' + GHandleOper[i] + '(' + GHandleDef[i] + '));\\n';

//					}

//					toolgroup += '}\\n';

//					trees=trees.substring(idx2+1);
				


//				}
//			else if(trees[0]==']'){
//				toolgroup += '}\\n';
//				trees=trees.substring(1);

//			}
//		//	else{ var ss = trees; break;}
//		}// end of while

		 
//	geodefinitionFunc = mainshape+toolgroup;

//	cc = 'function frep(x1,y1,z1,t){\\n'+geodefinitionFunc+'\\nreturn fun;}';
//	//print(cc);

//	}// end of if
			
	

//	else{ //parametric functions moving geometry

	
//   	m = addRotation(m,shape.grotation [0],shape.grotation [1],shape.grotation [2],shape.grotation [3]);
//	m = addScale(m,shape.gscale[0],shape.gscale[1],shape.gscale[2]);

//	m = addTranslation(m,shape.gtranslation[0],shape.gtranslation[1],shape.gtranslation[2]);

//	var FuncX = 'x*(' + toFix(m[0]) + ')+y*(' + toFix(m[1]) + ')+z*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
//	var FuncY = 'x*(' + toFix(m[4]) + ')+y*(' + toFix(m[5]) + ')+z*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
//	var FuncZ = 'x*(' + toFix(m[8]) + ')+y*(' + toFix(m[9]) + ')+z*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';

//	if(Geometry.indexOf('parametric')==-1){

//	cc = 'function parametric_x(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncX+'}';
//	cc +='function parametric_y(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncY+'}';
//	cc +='function parametric_z(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncZ+'}';
//}
//else{
//	var paraggs = split(Geometry, ';');
//	var paraggs2 = split(paraggs[0],'{');
//	var x2 = paragg2[1];
//	var y2 = paragg[1];
//	var z2 = paragg[2];
	
//	cc = 'function parametric_x(u,v,w,t){\\n'+x2+'\\nreturn '+ FuncX+'}';
//	cc +='function parametric_y(u,v,w,t){\\n'+y2+'\\nreturn '+ FuncY+'}';
//	cc +='function parametric_z(u,v,w,t){\\n'+z2+'\\nreturn '+ FuncZ+'}';
//}


//}

	




//}
	
 
//	///////////////end of new scripting////////////////////////
//	///////////////////////////////////////////////////////////



//	/////////////////////////////////////////
//	////following is original scripting//////////
//else{

//	var m = new Array(16);

//	m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
//	m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
//	m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
//	m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;

  	
	
////	if(geometry.definition.indexOf('frep')==-1) return;
//  	if(Geometry.indexOf('fun')!=-1){

//    m = addTranslation(m,-shape.gtranslation[0],-shape.gtranslation[1],-shape.gtranslation[2]);
//   	m = addRotation(m,shape.grotation [0],shape.grotation [1],shape.grotation [2],-shape.grotation [3]);
//	m = addScale(m,1/shape.gscale[0],1/shape.gscale[1],1/shape.gscale[2]);

////	if((Geometry.indexOf('x=')==-1)&&(Geometry.indexOf('y=')==-1)&&(Geometry.indexOf('z=')==-1)){
//	mainshape += 'x=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
//	mainshape += 'y=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
//	mainshape += 'z=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');';
////}
////	else{
////		mainshape += 'u=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
////		mainshape += 'v=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
////		mainshape += 'w=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
////	}


//	mainshape += Geometry+'\\n';



 
	
	
//	for(var i=0;i<GHandleNum;i++){

//		var deled = 0;
//		for(var j=0;j<deledN;j++){
//			if(DeledTool[j]==GHandName[i]) deled = 1;
//		}

//		if(!deled){
//		m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
//		m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
//		m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
//		m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;


//		//tempTranslation[0] = 
//		m = addTranslation(m, -GHandleTrans[i][0], -GHandleTrans[i][1], -GHandleTrans[i][2]);
//		m = addRotation(m, GHandleRotate[i][0], GHandleRotate[i][1], GHandleRotate[i][2], -GHandleRotate[i][3]);
//		m = addRotation(m, GHandleRoll[i][0], GHandleRoll[i][1], GHandleRoll[i][2], -GHandleRoll[i][3]);
//		m = addRotation(m, GHandlePitch[i][0], GHandlePitch[i][1], GHandlePitch[i][2], -GHandlePitch[i][3]);
//		m = addRotation(m, GHandleYaw[i][0], GHandleYaw[i][1], GHandleYaw[i][2], -GHandleYaw[i][3]);
//		m = addRotation(m, GHandleLocalRotate[i][0], GHandleLocalRotate[i][1], GHandleLocalRotate[i][2], -GHandleLocalRotate[i][3]);
//		m = addTranslation(m, -GHandleLocalTrans[i][0], -GHandleLocalTrans[i][1], -GHandleLocalTrans[i][2]);
//		m = addScale(m,1.0/GHandleScale[i][0],1.0/GHandleScale[i][1],1.0/GHandleScale[i][2]);

//		toolgroup += 'x=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
//		toolgroup += 'y=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
//		toolgroup += 'z=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
		
//		toolgroup += 'fun=fun' + GHandleOper[i] + '(' + GHandleDef[i] + '));\\n';
//	}
//	}




//	geodefinitionFunc = mainshape+toolgroup;
	

//	cc = 'function frep(x1,y1,z1,t){\\n'+geodefinitionFunc+'\\nreturn fun;}';

	

//}

//else{ //parametric functions moving geometry

	
//   	m = addRotation(m,shape.grotation [0],shape.grotation [1],shape.grotation [2],shape.grotation [3]);
//	m = addScale(m,shape.gscale[0],shape.gscale[1],shape.gscale[2]);

//	m = addTranslation(m,shape.gtranslation[0],shape.gtranslation[1],shape.gtranslation[2]);

//	var FuncX = 'x*(' + toFix(m[0]) + ')+y*(' + toFix(m[1]) + ')+z*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
//	var FuncY = 'x*(' + toFix(m[4]) + ')+y*(' + toFix(m[5]) + ')+z*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
//	var FuncZ = 'x*(' + toFix(m[8]) + ')+y*(' + toFix(m[9]) + ')+z*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';

//	if(Geometry.indexOf('parametric')==-1){

//	cc = 'function parametric_x(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncX+'}';
//	cc +='function parametric_y(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncY+'}';
//	cc +='function parametric_z(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncZ+'}';
//}
//else{
//	var paraggs = split(Geometry, ';');
//	var paraggs2 = split(paraggs[0],'{');
//	var x2 = paragg2[1];
//	var y2 = paragg[1];
//	var z2 = paragg[2];
	
//	cc = 'function parametric_x(u,v,w,t){\\n'+x2+'\\nreturn '+ FuncX+'}';
//	cc +='function parametric_y(u,v,w,t){\\n'+y2+'\\nreturn '+ FuncY+'}';
//	cc +='function parametric_z(u,v,w,t){\\n'+z2+'\\nreturn '+ FuncZ+'}';
//}


//}

//}
//		//////////////end of orignal scripting///////////////////////////////
//	//////////////////////////////////////////////////////////////////////



//	if(cc != geometryDefinition)
//	{

			
//	//	print(cc);
			
//				boundingBox();
//				//geometryDefinition = cc;
//				//wholegeometry.definition = geometryDefinition;
//	 			wholegeometry.definition = cc;
//				//geometry.definition = cc;

				
//				GRotation[GeometryArray] = shape.grotation;
//				GTranslation[GeometryArray] = shape.gtranslation;
//				GScale[GeometryArray] = shape.gscale;

//				bboxcenter[0] = wholegeometry.bboxCenter[0]+GTranslation[GeometryArray][0]-pgtrans[0];
//				bboxcenter[1] = wholegeometry.bboxCenter[1]+GTranslation[GeometryArray][1]-pgtrans[1];
//				bboxcenter[2] = wholegeometry.bboxCenter[2]+GTranslation[GeometryArray][2]-pgtrans[2];	

//			//	if(bboxcenter[0]<0.00001) bboxcenter[0] = 0;
//			//	if(bboxcenter[1]<0.00001) bboxcenter[1] = 0;
//			//	if(bboxcenter[2]<0.00001) bboxcenter[2] = 0;

//				bboxCenter = bboxcenter;
					


//				pgtrans[0] = GTranslation[GeometryArray][0];
//				pgtrans[1] = GTranslation[GeometryArray][1];
//				pgtrans[2] = GTranslation[GeometryArray][2];

//				GeometryArray=GeometryArray+1;
//				boundingBox();
			

//			}

//}

function editGeometry(){
		if (!initialized )
	{
		// If the shape is not initialized yet, discard any modifications.
		return;
	}

	
	var	geometryDefinition = wholegeometry.definition;
	//var Geometry = geometry.definition;
	var Geometry = shape.geoDef;
	var geodefinitionFunc = '';

	var mainshape = '';
	var toolgroup = '';

	var m = new Array(16);

	var ss = '';

	m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
	m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
	m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
	m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;

  	
	
//	if(geometry.definition.indexOf('frep')==-1) return;
  	if(Geometry.indexOf('fun')!=-1){

    m = addTranslation(m,-shape.gtranslation[0],-shape.gtranslation[1],-shape.gtranslation[2]);
   	m = addRotation(m,shape.grotation [0],shape.grotation [1],shape.grotation [2],-shape.grotation [3]);
	m = addScale(m,1/shape.gscale[0],1/shape.gscale[1],1/shape.gscale[2]);

//	if((Geometry.indexOf('x=')==-1)&&(Geometry.indexOf('y=')==-1)&&(Geometry.indexOf('z=')==-1)){
	mainshape += 'x=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
	mainshape += 'y=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
	mainshape += 'z=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');';
//}
//	else{
//		mainshape += 'u=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
//		mainshape += 'v=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
//		mainshape += 'w=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
//	}


	mainshape += Geometry+'\\n';

	
	for(var i=0;i<GHandleNum;i++){

		var deled = 0;
		for(var j=0;j<deledN;j++){
			if(DeledTool[j]==GHandName[i]) deled = 1;
		}

		if(!deled){
		m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
		m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
		m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
		m[12] = 0; m[13] = 0; m[14] = 0; m[15] = 1;


		//tempTranslation[0] = 
		m = addTranslation(m, -GHandleTrans[i][0], -GHandleTrans[i][1], -GHandleTrans[i][2]);
		m = addRotation(m, GHandleRotate[i][0], GHandleRotate[i][1], GHandleRotate[i][2], -GHandleRotate[i][3]);
		m = addRotation(m, GHandleRoll[i][0], GHandleRoll[i][1], GHandleRoll[i][2], -GHandleRoll[i][3]);
		m = addRotation(m, GHandlePitch[i][0], GHandlePitch[i][1], GHandlePitch[i][2], -GHandlePitch[i][3]);
		m = addRotation(m, GHandleYaw[i][0], GHandleYaw[i][1], GHandleYaw[i][2], -GHandleYaw[i][3]);
		m = addRotation(m, GHandleLocalRotate[i][0], GHandleLocalRotate[i][1], GHandleLocalRotate[i][2], -GHandleLocalRotate[i][3]);
		m = addTranslation(m, -GHandleLocalTrans[i][0], -GHandleLocalTrans[i][1], -GHandleLocalTrans[i][2]);
		m = addScale(m,1.0/GHandleScale[i][0],1.0/GHandleScale[i][1],1.0/GHandleScale[i][2]);

		toolgroup += 'x=x1*(' + toFix(m[0]) + ')+y1*(' + toFix(m[1]) + ')+z1*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
		toolgroup += 'y=x1*(' + toFix(m[4]) + ')+y1*(' + toFix(m[5]) + ')+z1*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
		toolgroup += 'z=x1*(' + toFix(m[8]) + ')+y1*(' + toFix(m[9]) + ')+z1*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';
		
		toolgroup += 'fun=fun' + GHandleOper[i] + '(' + GHandleDef[i] + '));\\n';
	}
	}

	geodefinitionFunc = mainshape+toolgroup;

	ss = 'function frep(x1,y1,z1,t){\\n'+geodefinitionFunc+'\\nreturn fun;}';

}
else{ //parametric functions moving geometry

	
   	m = addRotation(m,shape.grotation [0],shape.grotation [1],shape.grotation [2],shape.grotation [3]);
	m = addScale(m,shape.gscale[0],shape.gscale[1],shape.gscale[2]);

	m = addTranslation(m,shape.gtranslation[0],shape.gtranslation[1],shape.gtranslation[2]);

	var FuncX = 'x*(' + toFix(m[0]) + ')+y*(' + toFix(m[1]) + ')+z*(' + toFix(m[2]) + ')+(' + toFix(m[3]) + ');\\n';
	var FuncY = 'x*(' + toFix(m[4]) + ')+y*(' + toFix(m[5]) + ')+z*(' + toFix(m[6]) + ')+(' + toFix(m[7]) + ');\\n';
	var FuncZ = 'x*(' + toFix(m[8]) + ')+y*(' + toFix(m[9]) + ')+z*(' + toFix(m[10]) + ')+(' + toFix(m[11]) + ');\\n';

	if(Geometry.indexOf('parametric')==-1){

	ss = 'function parametric_x(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncX+'}';
	ss +='function parametric_y(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncY+'}';
	ss +='function parametric_z(u,v,w,t){\\n'+Geometry+'\\nreturn '+ FuncZ+'}';
}
else{
	var paraggs = split(Geometry, ';');
	var paraggs2 = split(paraggs[0],'{');
	var x2 = paragg2[1];
	var y2 = paragg[1];
	var z2 = paragg[2];
	
	ss = 'function parametric_x(u,v,w,t){\\n'+x2+'\\nreturn '+ FuncX+'}';
	ss +='function parametric_y(u,v,w,t){\\n'+y2+'\\nreturn '+ FuncY+'}';
	ss +='function parametric_z(u,v,w,t){\\n'+z2+'\\nreturn '+ FuncZ+'}';
}


}


	if(ss != geometryDefinition)
	{

			
	//	print(cc);
			
				boundingBox();
				//geometryDefinition = cc;
				//wholegeometry.definition = geometryDefinition;
	 			wholegeometry.definition = ss;

				
				GRotation[GeometryArray] = shape.grotation;
				GTranslation[GeometryArray] = shape.gtranslation;
				GScale[GeometryArray] = shape.gscale;

				//bboxcenter change
				//bboxcenter[0] = wholegeometry.bboxCenter[0]+GTranslation[GeometryArray][0]-pgtrans[0];
				//bboxcenter[1] = wholegeometry.bboxCenter[1]+GTranslation[GeometryArray][1]-pgtrans[1];
				//bboxcenter[2] = wholegeometry.bboxCenter[2]+GTranslation[GeometryArray][2]-pgtrans[2];	

		
				//bboxCenter = bboxcenter;
					


				pgtrans[0] = GTranslation[GeometryArray][0];
				pgtrans[1] = GTranslation[GeometryArray][1];
				pgtrans[2] = GTranslation[GeometryArray][2];

				GeometryArray=GeometryArray+1;
				boundingBox();
			

			}

}

function okUp(){

	tick();
	

}

function grot(grot){

	grotf[0] = grot[0];
	grotf[1] = grot[1];
	grotf[2] = grot[2];
	grotf[3] = grot[3];

}

function gtrans(gtrans){
	gtransf[0] = gtrans[0];
	gtransf[1] = gtrans[1];
	gtransf[2] = gtrans[2];

}
function gscale(gscale){
	gscalef[0] = gscale[0];
	gscalef[1] = gscale[1];
	gscalef[2] = gscale[2];

}

function arot(arot){
	arotf[0] = arot[0];
	arotf[1] = arot[1];
	arotf[2] = arot[2];
	arotf[3] = arot[3];

}

function atrans(atrans){
	atransf[0] = atrans[0];
	atransf[1] = atrans[1];
	atransf[2] = atrans[2];
}
function ascale(ascale){
	ascalef[0] = ascale[0];
	ascalef[1] = ascale[1];
	ascalef[2] = ascale[2];
}

function gtransUp(){

	shapeRotationOut[0] = grotf[0];
	shapeRotationOut[1] = grotf[1];
	shapeRotationOut[2] = grotf[2];
	shapeRotationOut[3] = grotf[3];

	shapeTranslationOut[0] = gtransf[0];
	shapeTranslationOut[1] = gtransf[1];
	shapeTranslationOut[2] = gtransf[2];

	shapeScaleOut[0] = gscalef[0];
	shapeScaleOut[1] = gscalef[1];
	shapeScaleOut[2] = gscalef[2];

	tick();
}

function atransUp(){


	appearanceRotationOut[0] = arotf[0];
	appearanceRotationOut[1] = arotf[1];
	appearanceRotationOut[2] = arotf[2];
	appearanceRotationOut[3] = arotf[3];

	appearanceTranslationOut[0] = atransf[0];
	appearanceTranslationOut[1] = atransf[1];
	appearanceTranslationOut[2] = atransf[2];

	appearanceScaleOut[0] = ascalef[0];
	appearanceScaleOut[1] = ascalef[1];
	appearanceScaleOut[2] = ascalef[2];

	tick();
}


function tick()
{
		editColor();
		editGeometry();
		refreshform();

}

function refreshfromchat()
{
   refreshform();
}
function loadmodel(){
	load();
}


//#!--end added

function displace()
{
	toolDisplaceSensor = true;
	toolRotateSensor = false;
	toolScaleSensor = false;
	toolMoveSensor = false;
	toolRollSensor = false;
	toolPitchSensor = false;
	toolYawSensor = false;

	//#--added
//	modelDisplaceSensor = true;
//	modelRotateSensor = false;
//	modelScaleSensor = false;
//	modelMoveSensor = false;
//	modelRollSensor = false;
//	modelPitchSensor = false;
//	modelYawSensor = false;
	//#!--end added

	toolDisplaceColor = new SFColor(0.4,1,0.8);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	toolMoveColor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);
}
function rotate()
{
	toolDisplaceSensor = false;
	toolRotateSensor = true;
	toolScaleSensor = false;
	toolMoveSensor = false;
	toolRollSensor = false;
	toolPitchSensor = false;
	toolYawSensor = false;

	//#--added
	modelDisplaceSensor = false;
	modelRotateSensor = true;
	modelScaleSensor = false;
	modelMoveSensor = false;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = false;
	//#!--end added

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.4,1,0.8);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolMoveColor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);
}
function scale()
{
	toolDisplaceSensor = false;
	toolRotateSensor = false;
	toolScaleSensor = true;
	toolMoveSensor = false;
	toolRollSensor = false;
	toolPitchSensor = false;
	toolYawSensor = false;

	//#--added
	modelDisplaceSensor = false;
	modelRotateSensor = false;
	modelScaleSensor = true;
	modelMoveSensor = false;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = false;
	//#!--end added

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.4,1,0.8);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolMoveColor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);
}
function move()
{
	toolDisplaceSensor = false;
	toolRotateSensor = false;
	toolScaleSensor = false;
	toolMoveSensor = true;
	toolRollSensor = false;
	toolPitchSensor = false;
	toolYawSensor = false;

	//#--added
//	modelDisplaceSensor = false;
//	modelRotateSensor = false;
//	modelScaleSensor = false;
//	modelMoveSensor = true;
//	modelRollSensor = false;
//	modelPitchSensor = false;
//	modelYawSensor = false;
	//#!--end added

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	toolMoveColor = new SFColor(0.4,1,0.8);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);
}

//#--added for moveXYZ
function moveX()
{

	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = true;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = false;

	//toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.4,1,0.8);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);

	moveXYZ = 1;
	modelMoveOffset = zeroTranslation;
//	modelMoveIn(modelMoveOffset);
}

function moveY()
{

	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = true;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = false;

	//toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.4,1,0.8);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);

	moveXYZ = 2;
	modelMoveOffset = zeroTranslation;
//	modelMoveIn(modelMoveOffset);
}

function moveZ()
{

	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = true;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = false;

	//toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.4,1,0.8);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);

	moveXYZ = 3;
	modelMoveOffset = zeroTranslation;
//	modelMoveIn(modelMoveOffset);
}


//#!--end added

function roll()
{
	toolDisplaceSensor = false;
	toolRotateSensor = false;
	toolScaleSensor = false;
	toolMoveSensor = false;
	toolRollSensor = true;
	toolPitchSensor = false;
	toolYawSensor = false;

	//#--added
	modelDisplaceSensor = false;
	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = false;
	modelRollSensor = true;
	modelPitchSensor = false;
	modelYawSensor = false;
	//#!--end added

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolMoveColor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.4,1,0.8);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.8,0.4,1);
}
function pitch()
{
	toolDisplaceSensor = false;
	toolRotateSensor = false;
	toolScaleSensor = false;
	toolMoveSensor = false;
	toolRollSensor = false;
	toolPitchSensor = true;
	toolYawSensor = false;

	//#--added
	modelDisplaceSensor = false;
	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = false;
	modelRollSensor = false;
	modelPitchSensor = true;
	modelYawSensor = false;
	//#!--end added

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolMoveColor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.4,1,0.8);
	toolYawColor = new SFColor(0.8,0.4,1);
}
function yaw()
{
	toolDisplaceSensor = false;
	toolRotateSensor = false;
	toolScaleSensor = false;
	toolMoveSensor = false;
	toolRollSensor = false;
	toolPitchSensor = false;
	toolYawSensor = true;

	//#--added
	modelDisplaceSensor = false;
	modelRotateSensor = false;
	modelScaleSensor = false;
	modelMoveSensor = false;
	modelRollSensor = false;
	modelPitchSensor = false;
	modelYawSensor = true;
	//#!--end added

	toolDisplaceColor = new SFColor(0.8,0.4,1);
	toolRotateColor = new SFColor(0.8,0.4,1);
	toolScaleColor = new SFColor(0.8,0.4,1);
	moveXcolor = new SFColor(0.8,0.4,1);
	moveYcolor = new SFColor(0.8,0.4,1);
	moveZcolor = new SFColor(0.8,0.4,1);
	toolMoveColor = new SFColor(0.8,0.4,1);
	toolRollColor = new SFColor(0.8,0.4,1);
	toolPitchColor = new SFColor(0.8,0.4,1);
	toolYawColor = new SFColor(0.4,1,0.8);

}

//#--changed
function resetTool()
{

//	if(showModel==1){ 
	
	toolRotateOffset = new SFRotation(0, 1, 0, 0);
	toolDisplaceOffset = new SFVec3f(0, 0, 0);
	toolScaleOffset = new SFVec3f(0, 0, 0);
	toolMoveOffset = new SFVec3f(0, 0, 0);
	toolRollOffset = 0;
	toolPitchOffset = 0;
	toolYawOffset = 0;


	toolTranslationValue = toolDisplaceOffset;
	toolRotationValue = toolRotateOffset;
	toolRotationIn(toolRotateOffset);
	toolTranslationIn(toolDisplaceOffset);
	toolScaleIn(toolScaleOffset);
	toolMoveIn(toolMoveOffset);
		
	var rr = new SFRotation(0, 1, 0, 0);
	toolRollIn(rr);
	toolPitchIn(rr);
	toolYawIn(rr);
//	}

	//#!--end added	    and end changed

}


//#--changed
function resetCoordinate()
{
//	if(showModel==0){
//	var origmoveshape = moveshapeflag;
//	var origmoveappearance = moveappearanceflag;
	var origmoveXYZ = moveXYZ;

//	moveshapeflag =true;	  //for enable assign
//	moveappearanceflag = true;

	modelRotateOffset = zeroRotation;
//	modelDisplaceOffset = zeroTranslation;
	modelScaleOffset = zeroScale;
	modelMoveOffset = zeroTranslation;
	modelRollOffset = 0;
	modelPitchOffset = 0;
	modelYawOffset = 0;

	modelRotationIn(modelRotateOffset);
//	modelTranslationIn(modelDisplaceOffset);
	modelScaleIn(modelScaleOffset);
	moveXYZ = 1;
	modelMoveIn(modelMoveOffset);
	moveXYZ = 2;
	modelMoveIn(modelMoveOffset);
	moveXYZ = 3;
	modelMoveIn(modelMoveOffset);

	modelRollIn(modelRotateOffset);
	modelPitchIn(modelRotateOffset);
	modelYawIn(modelRotateOffset);


//	moveshapeflag = origmoveshape;
//	moveappearanceflag = origmoveappearance;
	moveXYZ = origmoveXYZ;

	if(moveshapeflag) GeometryArray=0;
	else AppearanceArray = 0;

	//print('3shape.gtranslation'+shape.gtranslation );

	tick();
 
	//#!--end added	    and end changed
//}
}

//#-- added	

function resetshape(){
		var str1 = 'shape:1-sqrt(x*x+y*y+z*z)#color:r=0.7;g=0.7;b=0.7;#texture:0#parameters:0#resolution:100,100,100#bboxsize:2.5,2.5,2.5 #bboxcenter:0,0,0#patterncolor:0,1,0,1,0,0#patternkey:0.3,0.7#loop:false#polygonizer:analytical#cycleinterval:1#geometrytimespan:0,1#colortimespan:0,1#texturetimespan:0,1';
		receiveChat = '';
		receiveChat = str1;																											//
			
		resetCoord();


		//reset material thing
		specularColor = 'r=0;g=0;b=0;';
		emissiveColor = 'r=0;g=0;b=0;';
		ambientIntensity = '1';
		transparency = '0';
		ambientIntensity = '1';
		shininess = '1';


		resetHGN = Browser.createVrmlFromString(resetHG);
		resetGroup.children = resetHGN;
		addHandle = resetGroup.getSubNodeById('@HandleGroup');

		GID = 0;
		AID = 0;

		GHandleNum = 0;
		AHandleNum = 0;

		reservGN = 0;
		reservAN = 0;

		
		
}


function resetCoord(t){
	boundingBox();
	GeometryArray=0;
	AppearanceArray=0;
//	GHandleNum = 0;
//	AHandleNum = 0;
	pgtrans = zeroTranslation;

	gtransf = zeroTranslation;
	gscalef = zeroScale;
	grotf = zeroRotation;

	atransf = zeroTranslation;
	ascalef = zeroScale;
	arotf = zeroRotation;

	bboxCenter = zeroTranslation;

	var origmoveshape = moveshapeflag;
	var origmoveappearance = moveappearanceflag;

	moveshapeflag =true;	  //for enable assign
	moveappearanceflag = true;


	modelRotateOffset = zeroRotation;
//	modelDisplaceOffset = zeroTranslation;
	modelScaleOffset = zeroScale;
	modelMoveOffset = zeroTranslation;
	modelRollOffset = 0;
	modelPitchOffset = 0;
	modelYawOffset = 0;

	modelRotationIn(modelRotateOffset);
//	modelTranslationIn(modelDisplaceOffset);
	modelScaleIn(modelScaleOffset);
	modelMoveIn(modelMoveOffset);
	modelRollIn(modelRotateOffset);
	modelPitchIn(modelRotateOffset);
	modelYawIn(modelRotateOffset);

	shapeRotationOut[0] = 0;
	shapeRotationOut[1] = 0;
	shapeRotationOut[2] = 1;
	shapeRotationOut[3] = 0;

	shapeTranslationOut[0] = 0;
	shapeTranslationOut[1] = 0;
	shapeTranslationOut[2] = 0;

	shapeScaleOut[0] = 1;
	shapeScaleOut[1] = 1;
	shapeScaleOut[2] = 1;


	appearanceRotationOut[0] = 0;
	appearanceRotationOut[1] = 0;
	appearanceRotationOut[2] = 1;
	appearanceRotationOut[3] = 0;

	appearanceTranslationOut[0] = 0;
	appearanceTranslationOut[1] = 0;
	appearanceTranslationOut[2] = 0;

	appearanceScaleOut[0] = 1;
	appearanceScaleOut[1] = 1;
	appearanceScaleOut[2] = 1;


	moveshapeflag = origmoveshape;
	moveappearanceflag = origmoveappearance;


	boundingBox();


}

function saveAssemble(){

	modelStr = '';

	modelStr = '-------------Save Start-------------- \n'
			+ '`'+ shape.geoDef
			+ '`'+ assembleVec3f(shape.gtranslation)
			+ '`'+ assembleSFRotation(shape.grotation)
			+ '`'+ assembleVec3f(shape.gscale)
			+ '`' + assembleVec3f(wholegeometry.bboxCenter)
			+ '`' + assembleVec3f(wholegeometry.bboxSize) 
			+ '`' + assembleFloatArray(wholegeometry.resolution)
			+ '`' + assembleFloatArray(wholegeometry.parameters) 
			+ '`' + assembleColorArray(wholematerial.patternColor)
			+ '`' + assembleFloatArray(wholematerial.patternKey) 
			+ '`' + wholematerial.transparency
			+ '`' + wholematerial.emissiveColor
			+ '`' + wholematerial.ambientIntensity
			+ '`' + wholematerial.specularColor
			+ '`' + wholematerial.shininess
			+ '`' + wholematerial.type

			+ '`' + wholeshape.polygonizer  
			+ '`' + wholeshape.cycleInterval
			+ '`' + wholeshape.loop
			+ '`' + assembleVec2f(wholematerial.timeSpan) 
			//+ ''
			+ '`' + wholetexture.definition 
			+ '`' + assembleVec2f(wholetexture.timeSpan)
			+ '`' + assembleVec2f(wholegeometry.timeSpan) 
			+ '`' + shape.difusecolorDef
			+ '`' + assembleVec3f(shape.atranslation)
			+ '`' + assembleSFRotation(shape.arotation)
			+ '`' + assembleVec3f(shape.ascale)
			+ '`' + GHandleNum
			+ '`'+ assembleMFString(GHandleDef,GHandleNum) 
			+ '`'+ assembleVec3fArray(GHandleTrans,GHandleNum)
			+ '`'+ assembleSFRotationArray(GHandleRotate,GHandleNum) 
			+ '`'+ assembleVec3fArray(GHandleScale,GHandleNum) 
			+ '`'+ assembleSFRotationArray(GHandleYaw,GHandleNum)
			+ '`'+ assembleSFRotationArray(GHandlePitch,GHandleNum) 
			+ '`'+ assembleSFRotationArray(GHandleRoll,GHandleNum)   
			+ '`'+ assembleSFRotationArray(GHandleLocalRotate,GHandleNum) 
			+ '`'+ assembleVec3fArray(GHandleLocalTrans,GHandleNum)
			+ '`'+ assembleMFString(GHandleOper,GHandleNum) 
			+ '`'+ AHandleNum
			+ '`'+ assembleMFString(AHandleDef,AHandleNum) 
			+ '`'+ assembleVec3fArray(AHandleTrans,AHandleNum)
			+ '`'+ assembleSFRotationArray(AHandleRotate,AHandleNum)
			+ '`'+ assembleVec3fArray(AHandleScale,AHandleNum) 
			+ '`'+ assembleSFRotationArray(AHandleYaw,AHandleNum)
			+ '`'+ assembleSFRotationArray(AHandlePitch,AHandleNum)
			+ '`'+ assembleSFRotationArray(AHandleRoll,AHandleNum)  
			+ '`'+ assembleSFRotationArray(AHandleLocalRotate,AHandleNum)
			+ '`'+ assembleVec3fArray(AHandleLocalTrans,AHandleNum)
			+ '`'+ assembleFloatArray(AColorR,AHandleNum)
			+ '`'+ assembleFloatArray(AColorG,AHandleNum)
		    + '`'+ assembleFloatArray(AColorB,AHandleNum)
			+ '`'+ assembleFloatArray(AAlpha,AHandleNum)
			+ '`'+'\n--------------Save End---------------';

} 



"
}

ROUTE Touch.hitPoint_changed TO	Modeller.coordinateIn
ROUTE Touch.hitNormal_changed TO Modeller.normalIn
ROUTE Touch.touchTime TO Modeller.click
ROUTE Touch.isOver TO Modeller.isOver
ROUTE Modeller.sendMessage TO ShapeMsg.set_string
ROUTE ShapeMsg.string_changed TO Modeller.receiveMessage
ROUTE Keybord.keyPress TO Modeller.key
ROUTE CoordinateSys.touchTime TO Modeller.coordinateSys
ROUTE BoundingBox.touchTime TO Modeller.boundingBox
ROUTE Remove.touchTime TO Modeller.remove
ROUTE Deposit.touchTime	TO Modeller.deposit

#ROUTE Edit.touchTime TO	Modeller.edit

ROUTE Undo.touchTime TO Modeller.undo
ROUTE Cancel.touchTime TO Modeller.cancel
ROUTE Rotate.touchTime TO Modeller.rotate
ROUTE Roll.touchTime TO	Modeller.roll
ROUTE Pitch.touchTime TO Modeller.pitch
ROUTE Yaw.touchTime	TO Modeller.yaw
ROUTE Displace.touchTime TO Modeller.displace
ROUTE Scale.touchTime TO Modeller.scale
ROUTE Move.touchTime TO	Modeller.move
#--added for moveXYZ
ROUTE MoveX.touchTime TO Modeller.moveX
ROUTE MoveY.touchTime TO Modeller.moveY
ROUTE MoveZ.touchTime TO Modeller.moveZ
ROUTE Modeller.moveXcolor TO MoveX.color
ROUTE Modeller.moveYcolor TO MoveY.color
ROUTE Modeller.moveZcolor TO MoveZ.color
#!--end added

ROUTE Color.touchTime TO Modeller.applycolor
ROUTE UndoColor.touchTime TO Modeller.undocolor
ROUTE ResetTool.touchTime TO Modeller.resetTool
ROUTE ResetCoord.touchTime TO Modeller.resetCoordinate

ROUTE Modeller.requestLock TO Lock.set_string
ROUTE Lock.string_changed TO Modeller.lock
ROUTE Init.string_changed TO Modeller.initLock
ROUTE Modeller.outInit TO Init.set_string
ROUTE MsgLock.string_changed TO	Modeller.msgLock
ROUTE Modeller.setMsgLock TO MsgLock.set_string
ROUTE SendTimer.cycleTime TO Modeller.sendOneMsg
ROUTE InitTimer.cycleTime TO Modeller.init
ROUTE Modeller.showHideTool	TO ShowHideTool.whichChoice
ROUTE ToolRotationSensor.rotation_changed TO ToolLocalRotationTransform.rotation
ROUTE ToolRotationSensor.offset TO ToolLocalRotationTransform.rotation
ROUTE ToolRotationSensor.rotation_changed TO Modeller.toolLocalRotationIn
ROUTE ToolDisplacementSensor.translation_changed TO	Modeller.toolTranslationIn
ROUTE ToolScaleSensor.translation_changed TO Modeller.toolScaleIn
ROUTE ToolMoveSensor.translation_changed TO	Modeller.toolMoveIn
ROUTE ToolRollSensor.rotation_changed TO Modeller.toolRollIn
ROUTE ToolPitchSensor.rotation_changed TO Modeller.toolPitchIn
ROUTE ToolYawSensor.rotation_changed TO	Modeller.toolYawIn
ROUTE Modeller.toolTranslationOut TO ToolTransform.translation
ROUTE Modeller.toolRotationOut TO ToolTransform.rotation
ROUTE Modeller.toolScaleOut TO ToolLocalTransform.scale
ROUTE Modeller.toolMoveOut TO ToolLocalTransform.translation
ROUTE Modeller.toolRollOut TO ToolRollTransform.rotation
ROUTE Modeller.toolPitchOut	TO ToolPitchTransform.rotation
ROUTE Modeller.toolYawOut TO ToolYawTransform.rotation
ROUTE Modeller.touchSensor TO Touch.enabled
ROUTE Modeller.toolRotateSensor TO ToolRotationSensor.enabled
ROUTE Modeller.toolDisplaceSensor TO ToolDisplacementSensor.enabled
ROUTE Modeller.toolScaleSensor TO ToolScaleSensor.enabled
ROUTE Modeller.toolMoveSensor TO ToolMoveSensor.enabled
ROUTE Modeller.toolRollSensor TO ToolRollSensor.enabled
ROUTE Modeller.toolPitchSensor TO ToolPitchSensor.enabled
ROUTE Modeller.toolYawSensor TO	ToolYawSensor.enabled
ROUTE Modeller.toolDisplaceColor TO	Displace.color
ROUTE Modeller.toolRotateColor TO Rotate.color
ROUTE Modeller.toolScaleColor TO Scale.color
ROUTE Modeller.toolMoveColor TO	Move.color
ROUTE Modeller.toolRollColor TO	Roll.color
ROUTE Modeller.toolPitchColor TO Pitch.color
ROUTE Modeller.toolYawColor	TO Yaw.color
ROUTE Modeller.toolRotateOffset	TO ToolRotationSensor.offset
ROUTE Modeller.toolDisplaceOffset TO ToolDisplacementSensor.offset
ROUTE Modeller.toolScaleOffset TO ToolScaleSensor.offset
ROUTE Modeller.toolMoveOffset TO ToolMoveSensor.offset
ROUTE Modeller.toolRollOffset TO ToolRollSensor.offset
ROUTE Modeller.toolPitchOffset TO ToolPitchSensor.offset
ROUTE Modeller.toolYawOffset TO	ToolYawSensor.offset

#--added
ROUTE	Modeller.showModel TO MModel.whichChoice
ROUTE	Modeller.showOp	TO SwOpText.whichChoice

ROUTE ModelRotationSensor.rotation_changed TO Modeller.modelRotationIn

#ROUTE ModelDisplacementSensor.translation_changed TO Modeller.modelTranslationIn

ROUTE ModelScaleSensor.translation_changed TO Modeller.modelScaleIn
ROUTE ModelMoveSensor.translation_changed TO Modeller.modelMoveIn
ROUTE ModelPitchSensor.rotation_changed	TO Modeller.modelPitchIn
ROUTE ModelRollSensor.rotation_changed TO Modeller.modelRollIn
ROUTE ModelYawSensor.rotation_changed TO Modeller.modelYawIn

ROUTE Modeller.modelRotateSensor TO	ModelRotationSensor.enabled

#ROUTE Modeller.modelDisplaceSensor TO ModelDisplacementSensor.enabled

ROUTE Modeller.modelScaleSensor	TO ModelScaleSensor.enabled
ROUTE Modeller.modelMoveSensor TO ModelMoveSensor.enabled
ROUTE Modeller.modelPitchSensor	TO ModelPitchSensor.enabled
ROUTE Modeller.modelRollSensor TO ModelRollSensor.enabled
ROUTE Modeller.modelYawSensor TO ModelYawSensor.enabled

ROUTE Modeller.shapeRotationOut	TO Shape.grotation
ROUTE Modeller.shapeTranslationOut TO Shape.gtranslation
ROUTE Modeller.shapeScaleOut TO	Shape.gscale


#ROUTE Modeller.shapeRotationOut	TO WholeShapeTransform.rotation
#ROUTE Modeller.shapeTranslationOut TO WholeShapeTransform.translation
#ROUTE Modeller.shapeScaleOut TO	WholeShapeTransform.scale

ROUTE Modeller.appearanceRotationOut TO	Shape.arotation
ROUTE Modeller.appearanceTranslationOut	TO Shape.atranslation
ROUTE Modeller.appearanceScaleOut TO Shape.ascale

ROUTE MoveableShape.touchTime TO Modeller.moveableShape


ROUTE MoveableAppearance.touchTime TO Modeller.moveableAppearance
ROUTE WholeModelT.touchTime TO Modeller.wholeModelT


ROUTE Modeller.modelRotateOffset	TO ModelRotationSensor.offset

#ROUTE Modeller.modelDisplaceOffset TO ModelDisplacementSensor.offset

ROUTE Modeller.modelScaleOffset TO ModelScaleSensor.offset
ROUTE Modeller.modelMoveOffset TO ModelMoveSensor.offset
ROUTE Modeller.modelRollOffset TO ModelRollSensor.offset
ROUTE Modeller.modelPitchOffset TO ModelPitchSensor.offset
ROUTE Modeller.modelYawOffset TO	ModelYawSensor.offset

ROUTE Modeller.appearancecoord TO Shape.coorappearance
ROUTE Modeller.geometrycoord TO	Shape.coorgeometry
ROUTE Modeller.appearancebox TO	Shape.boxappearance
ROUTE Modeller.geometrybox TO Shape.boxgeometry

ROUTE Modeller.showShapeCoord TO ShapeCoord.whichChoice
ROUTE Modeller.bboxCenter TO WholeGeometry.bboxCenter

#ROUTE WholeGeometry.bboxCenter TO Modeller.bboxcenter
#ROUTE Export.touchTime TO Modeller.texexport
#ROUTE Save.touchTime TO	Modeller.texsave


ROUTE ShowHandle.touchTime TO Modeller.ShowHandleIn
ROUTE UndoHide.touchTime TO	Modeller.UndoHideIn
ROUTE ShowAll.touchTime	TO Modeller.ShowAllIn
ROUTE HideTool.touchTime TO	Modeller.HideToolIn
ROUTE DeleTool.touchTime TO	Modeller.DeleToolIn
ROUTE UndoDele.touchTime TO	Modeller.UndoDeleIn


ROUTE Modeller.ShowHandleColor TO ShowHandle.color
ROUTE Modeller.HideToolColor TO	HideTool.color
ROUTE Modeller.DeleToolColor TO	DeleTool.color


ROUTE Modeller.ShowHandleOut TO	HandleGroupSwitch.whichChoice
ROUTE Modeller.wholemodelswitch	TO WholeModelSwitch.whichChoice

#ROUTE Load.touchTime TO	Modeller.load
ROUTE ResetShape.touchTime TO Modeller.resetshape
#!--added


#----added for more appearance
#eventOut SFString emissiveColor 
#	eventOut SFString ambientIntensity
#	eventOut SFString specularColor
#	eventOut SFString shininess
#	eventOut SFString matType
ROUTE Modeller.emissiveColor TO	WholeMaterial.emissiveColor
ROUTE Modeller.ambientIntensity	TO WholeMaterial.ambientIntensity
ROUTE Modeller.specularColor TO	WholeMaterial.specularColor
ROUTE Modeller.shininess TO	WholeMaterial.shininess
ROUTE Modeller.matType TO WholeMaterial.type
ROUTE Modeller.transparency	TO WholeMaterial.transparency

ROUTE Modeller.texDef TO WholeTexture.definition
ROUTE Modeller.texTimespan TO WholeTexture.timeSpan
ROUTE Modeller.texParameters TO	WholeTexture.parameters
ROUTE Modeller.texType TO WholeTexture.type

#---end of added for more appearance


 #---added
DEF	DynamicTrigger TimeSensor
{
	loop TRUE
}

DEF	MouseScript Script {
	eventIn SFVec2f client
	eventIn     SFVec2f     position 
	eventIn     SFBool      lButton 
	eventIn     SFBool      mButton 
	eventIn     SFBool      rButton 
	eventIn     SFFloat     mouseWheel

	eventOut SFBool setProcessEvents
	eventOut SFBool tick
	field SFBool lButtonActivated FALSE

	url	"vrmlscript:
	function lButton(v, t)
	{
	if(v =='1') lButtonActivated = true;
	else if(lButtonActivated) tick = !tick;
	
//		lbuttonText.string[0] = v;
//		setProcessEvents = true;
	}
	
	"
}

ROUTE ms.client	TO MouseScript.client
ROUTE ms.position TO MouseScript.position
ROUTE ms.lButton TO	MouseScript.lButton
ROUTE ms.mButton TO	MouseScript.mButton
ROUTE ms.mouseWheel	TO MouseScript.mouseWheel
ROUTE MouseScript.setProcessEvents TO ms.eventsProcessed
ROUTE MouseScript.tick TO  Modeller.tick


#ROUTE DynamicTrigger.fraction_changed TO Modeller.tick
#!---end added




#VRML V2.0 utf8

#******************************************************************
#
# Chat commands
#
#******************************************************************

#Chat commands
DEF ChatScript Script {

	eventOut SFBool refreshform 
	eventOut SFBool	loadmodel
	eventOut SFBool	savemodel
	eventOut SFBool	exportwrl

    eventIn SFString receiveChat 
	eventOut SFString source
	eventOut SFString geodefSource

	eventOut SFString color
	eventOut SFString difcolorSource

	eventOut MFFloat parameters
	eventOut MFFloat patternKey
	eventOut MFColor patternColor
	eventOut SFVec3f bboxSize
	eventOut SFVec3f bboxCenter
	eventOut SFBool bbox
	#eventOut SFInt32 bboxCenter1
	eventOut MFInt32 resolution
	eventOut MFColor bground
	eventOut SFString textureDef
	eventOut SFTime cycleInterval
	eventOut SFVec2f geometryTimeSpan
	eventOut SFVec2f colorTimeSpan
	eventOut SFVec2f textureTimeSpan
	eventOut SFString polygonizer
	eventOut SFBool	loop

	#--added
	field SFNode wholematerial USE WholeMaterial
	field SFNode wholetexture USE WholeTexture
	field SFNode wholeshape USE	WholeShape
	field SFNode shape USE Shape

	eventOut SFVec3f gmove
	eventOut SFVec3f amove
	eventOut SFRotation	grot
	eventOut SFRotation	arot
	eventOut SFVec3f gscale
	eventOut SFVec3f ascale

	eventOut SFBool	resetModellerShape
	eventOut SFBool	resetToolN

	eventOut SFRotation shapeRotationOut
	eventOut SFVec3f shapeTranslationOut
	eventOut SFVec3f shapeScaleOut

	eventOut SFRotation appearanceRotationOut
	eventOut SFVec3f appearanceTranslationOut
	eventOut SFVec3f appearanceScaleOut

	eventOut SFString ChatToBot #user input that send to bot

	field SFRotation zeroRotation 0 0 1 0
	field SFVec3f zeroTranslation 0 0 0
	field SFVec3f zeroScale 1 1 1

	field SFBool res TRUE
	field SFBool resTN TRUE

	field MFString address [""]

	field SFNode node USE ChatScript
	#field SFString event "addChildren"
	eventIn	SFNode isLoaded


#	eventOut SFString friction
#	eventOut SFString tension
#	eventOut SFString density
#	eventOut SFString forcefield

#	eventOut SFBool boolfriction
#	eventOut SFBool	booltension
#	eventOut SFBool	booldensity
#	eventOut SFBool	boolforcefield

	#!--end added

	field SFNode shape USE Shape
	field SFNode wholegeometry USE WholeGeometry
	field SFNode material USE Material
	field SFNode texture USE Texture
	field SFNode background USE background
	url "vrmlscript: 

function assembleVec3f(dd)
{
	return dd[0] + ',' + dd[1] + ',' + dd[2];
}

function assembleSFRotation(dd)
{
	var s = '';
	s = dd[0] + ',' + dd[1] + ',' + dd[2]+','+dd[3];
	return s;
}

function assembleVec2f(dd)
{
	return dd[0] + ',' + dd[1];
}
function assembleFloatArray(dd)
{
	var s = '';
	var first = true;
	for(var i=0;i<dd.length;++i)
	{
		if (first)
		{
			first = false;
		}
		else
		{
			s += ',';
		}
		s += dd[i];
	}
	return s;
}

function assembleColorArray(dd)
{
	var s = '';
	var first = true;
	for(var i=0;i<dd.length;++i)
	{
		if (first)
		{
			first = false;
		}
		else
		{
			s += ',';
		}
		s += assembleVec3f(dd[i]);
	}
	return s;
}
function escapeSource(s)
{
	var ss = '';
	for(var i=0;i<s.length;++i)
	{
		var c = s.charAt(i);

		if (c == '&') ss += '&amp;';
		else if (c == '<') ss += '&lt;';
		else if (c == '>') ss += '&gt;';
		else ss += c;
	}
	return ss;
}
function stripArray(s)
{
	s = s.toString();
	var ss = '';
	for(var i=0;i<s.length;++i)
	{
		var c = s.charAt(i);
		if (!(c == '[' || c == ']' || c == ',')) ss += c;
	}
	return ss;
}
	function trim(s)
	{
		var ss = s;
		for(var i=0;i<ss.length;++i)
			if(ss.charAt(i) != ' ')
				break;
		ss = ss.substring(i, ss.length);
		for(var i=ss.length-1;i>=0;--i)
			if(ss.charAt(i) != ' ')
				break;
		ss = ss.substring(0, i+1);
		return ss;
	}

	function split(s, c)
	{
		var ss = new Array('');
		var j = 0;
		for(var i=0;i<s.length;++i)
			if(s.charAt(i) == c)
			{
				++j;
				ss[j] = '';
			}
			else
				ss[j] += s.charAt(i);
		return ss;
	}



	//#--added
	function isLoaded(n){
		

	//print('inisLoaded');
	//print(n);
	
//	file.addChildren = n;


	}
	//#!--end added
    function receiveChat (str1, time)
	{  
		if(str1.toLowerCase() == 'export')
		{

			
/*
			print('--------------------------');
//			print('Transform { ');
//			print('translation '+shape.gtranslation );
//			print('rotation '+shape.grotation );
//			print('scale '+shape.gscale );
//			print('children [');
			print('FShape {');
		//	print('scale');
			print('polygonizer \"' + wholeshape.polygonizer + '\"');
			print('	loop ' + (wholeshape.loop ? 'TRUE' : 'FALSE'));
			print('	cycleInterval ' + wholeshape.cycleInterval);
			print('	appearance FAppearance {');
			print('		material FMaterial {');
			print('			diffuseColor \"' + wholematerial.diffuseColor + '\"');
			print('			patternKey ' + wholematerial.patternKey);
			print('			patternColor ' + wholematerial.patternColor);
			print('			timeSpan ' + wholematerial.timeSpan);
			print('		}');
			print('		texture3D FTexture3D {');
			print('			definition \"' + wholetexture.definition + '\"');
			print('			timeSpan ' + wholetexture.timeSpan);
			print('         type \"displacement\"');
			print('		}');
			print('	}');
			print('	geometry FGeometry {');
			print('		definition \"' + wholegeometry.definition + '\"');
			print('		parameters ' + wholegeometry.parameters);
			print('		bboxSize ' + wholegeometry.bboxSize);
			print('		bboxCenter ' + wholegeometry.bboxCenter);
			print('		resolution ' + wholegeometry.resolution);
			print('		timeSpan ' + wholegeometry.timeSpan);
			print('	}');
			print('}');
//			print('	]');
//			print('}');		
			print('--------------------------');

			Browser.showConsole();

			*/
				var saveshape = '';
			saveshape +='FShape {';
			saveshape +='polygonizer \"' + wholeshape.polygonizer + '\"';
			saveshape +='	loop ' + (wholeshape.loop ? 'TRUE' : 'FALSE');
			saveshape +='	cycleInterval ' + wholeshape.cycleInterval;
			saveshape +='	appearance FAppearance {';
			saveshape +='		material FMaterial {';
			saveshape +='			diffuseColor \"' + wholematerial.diffuseColor + '\"';
			saveshape +='			patternKey ' + wholematerial.patternKey;
			saveshape +='			patternColor ' + wholematerial.patternColor;
			saveshape +='			timeSpan ' + wholematerial.timeSpan;
			saveshape +='		}';
			saveshape +='		texture3D FTexture3D {';
			saveshape +='			definition \"' + wholetexture.definition + '\"';
			saveshape +='			timeSpan ' + wholetexture.timeSpan;
			saveshape +='         type \"displacement\"';
			saveshape +='		}';
			saveshape +='	}';
			saveshape +='	geometry FGeometry {';
			saveshape +='		definition \"' + wholegeometry.definition + '\"';
			saveshape +='		parameters ' + wholegeometry.parameters;
			saveshape +='		bboxSize ' + wholegeometry.bboxSize;
			saveshape +='		bboxCenter ' + wholegeometry.bboxCenter;
			saveshape +='		resolution ' + wholegeometry.resolution;
			saveshape +='		timeSpan ' + wholegeometry.timeSpan;
			saveshape +='	}';
			saveshape +='}';

			var head = '';
			head += 'EXTERNPROTO FGeometry [';
			head += 'exposedField SFString definition';
			head += 'exposedField MFFloat parameters';
			head += 'exposedField MFInt32 resolution';
			head += 'exposedField SFVec3f bboxCenter';
			head += 'exposedField SFVec3f bboxSize';
			head += 'exposedField SFString type';
			head += 'exposedField MFNode	parents';
			head += 'exposedField SFVec2f timeSpan';
			head += '] \"FVRML.wrl#FGeometry\"';
			head += 'EXTERNPROTO FMaterial [';
			head += 'exposedField SFString diffuseColor';
			head += 'exposedField SFString type';
			head += 'exposedField MFColor patternColor';
			head += 'exposedField MFFloat patternKey';
			head += 'exposedField SFString ambientIntensity';
			head += 'exposedField SFString emissiveColor';
			head += 'exposedField SFString shininess';
			head += 'exposedField SFString specularColor';
			head += 'exposedField SFString transparency';
			head += 'exposedField MFFloat parameters';
			head += 'exposedField MFNode	parents';
			head += 'exposedField SFVec2f timeSpan';
			head += '] \"FVRML.wrl#FMaterial\"';
			head += 'EXTERNPROTO FTexture3D [';
			head += 'exposedField SFString definition';
			head += 'exposedField SFString type';
			head += 'exposedField MFFloat parameters';				
			head += 'exposedField MFNode	parents';
			head += 'exposedField SFVec2f timeSpan';
			head += '] \"FVRML.wrl#FTexture3D\"';
			head += 'EXTERNPROTO FAppearance [';
			head += 'exposedField SFNode	material';
			head += 'exposedField SFNode	texture';
			head += 'exposedField SFNode	textureTransform';
			head += 'exposedField SFNode	texture3D';
			head += 'exposedField MFNode	parents';
			head += 'eventIn	SFBool refresh';
			head += '] \"FVRML.wrl#FAppearance\"';
			head += 'EXTERNPROTO FShape [';
			head += 'exposedField SFNode	geometry';
			head += 'exposedField SFNode	appearance';
			head += 'exposedField SFString polygonizer';
			head += 'exposedField MFNode	parents';
			head += 'exposedField SFTime	startTime';
			head += 'exposedField SFTime stopTime';				
			head += 'exposedField SFTime cycleInterval';
			head += 'exposedField SFBool	loop';
			head += 'exposedField SFBool	enabled';
			head += 'eventOut SFTime	cycleTime';
			head += 'eventIn SFFloat set_fraction';
			head += 'field SFInt32 frames';
			head += '] \"FVRML.wrl#FShape\"';
			head += 'EXTERNPROTO FTransform [';
			head += 'exposedField SFString operation';
			head += 'exposedField SFString type';
			head += 'exposedField SFString polygonizer';
			head += 'exposedField MFFloat parameters';
			head += 'exposedField SFString center';
			head += 'exposedField SFString rotation';
			head += 'exposedField SFString scale';
			head += 'exposedField SFString scaleOrientation';
			head += 'exposedField SFString translation';
			head += 'exposedField MFNode children';				
			head += 'exposedField MFNode	parents';
			head += 'eventIn	SFBool refresh';
			head += 'exposedField SFVec2f timeSpan';
			head += 'exposedField SFTime	startTime';
			head += 'exposedField SFTime stopTime';
			head += 'exposedField SFTime cycleInterval';
			head += 'exposedField SFBool	loop';
			head += 'exposedField SFBool	enabled';
			head += 'eventOut SFTime	cycleTime';
			head += 'eventIn SFFloat set_fraction';
			head += 'field SFInt32 frames';			
			head += '] \"FVRML.wrl#FTransform\"';


//			head += 'NavigationInfo {';
//			head += '	type [\"EXAMINE\",\"ANY\"]';
//			head += '}';	
//			head += 'Viewpoint {';				
//			head += 'fieldOfView 0.7';	
//			head += 'position 0 0 5';	
//			head += 'description \"Overview\"';	
//			head += '	}';					
			

		//	var create = '';
			create = head+saveshape;
		//	


		//	var tempNode = Browser.createVrmlFromString(saveshape);

			//var ret = Browser.saveNode(tempNode,'head','writeProtos=false,writeExternProtos=true,filter=VRML Files|*.wrl||,title=Save Node as...,defaultExt=*.wrl');

			exportwrl = !exportwrl;
		}
		else if(str1.toLowerCase() == 'exportx3d')
		{
			print('--------------------------');
    		print('<ProtoInstance name=\"FShape\">');
    		print('  <fieldValue name=\"cycleInterval\" value=\"' + wholeshape.cycleInterval + '\" />');
            print('  <fieldValue name=\"loop\" value=\"' + (wholeshape.loop ? 'true' : 'false') + '\" />');
    		print('  <fieldValue name=\"polygonizer\" value=\"' + wholeshape.polygonizer + '\" />');
            print('  <fieldValue name=\"bboxSize\" value=\"' + wholegeometry.bboxSize + '\" />');
            print('  <fieldValue name=\"bboxCenter\" value=\"' + wholegeometry.bboxCenter + '\" />');
    		print('  <fieldValue name=\"appearance\">');
			print('    <ProtoInstance name=\"FAppearance\">');
			print('      <fieldValue name=\"material\">');
            print('        <ProtoInstance name=\"FMaterial\">');
            print('          <fieldValue name=\"timeSpan\" value=\"' + wholematerial.timeSpan + '\" />');
            print('          <fieldValue name=\"diffuseColor\" value=\"' + escapeSource(wholematerial.diffuseColor) + '\" />');
            print('          <fieldValue name=\"patternColor\" value=\"' + stripArray(wholematerial.patternColor) + '\" />');
            print('          <fieldValue name=\"patternKey\" value=\"' + stripArray(wholematerial.patternKey)  + '\" />');
            print('        </ProtoInstance>');
            print('      </fieldValue>');
			print('      <fieldValue name=\"texture3D\">');
			print('        <ProtoInstance name=\"FTexture3D\">');
			print('          <fieldValue name=\"definition\" value=\"' + escapeSource(wholetexture.definition) + '\" />');
			print('          <fieldValue name=\"timeSpan\" value=\"' + wholetexture.timeSpan + '\" />');
			print('          <fieldValue name=\"type\" value=\"displacement\" />');
			print('        </ProtoInstance>');
			print('      </fieldValue>');
        	print('    </ProtoInstance>');
            print('  </fieldValue>');
            print('  <fieldValue name=\"geometry\">');
            print('    <ProtoInstance name=\"FGeometry\">');
            print('      <fieldValue name=\"resolution\" value=\"' + stripArray(wholegeometry.resolution) + '\" />');
			print('      <fieldValue name=\"parameters\" value=\"' + stripArray(wholegeometry.parameters) + '\" />');
            print('      <fieldValue name=\"definition\" value=\"' + escapeSource(wholegeometry.definition) + '\" />');
            print('    </ProtoInstance>');
            print('  </fieldValue>');
            print('</ProtoInstance>');
			print('--------------------------');
		}
		else if(str1.toLowerCase() == 'refresh')
		{
			source = wholegeometry.definition;
			geodefSource = shape.geoDef;

			//#--added
			 resetShape();
			//#!--end added
		}
		else if(str1.toLowerCase()=='import'){

			 address = Browser.openFileDialog(node);
			 print(address);
			 Browser.createVrmlFromURL(address,node,'isLoaded');

				print('after \n');
			
		

		}
		else if(str1.toLowerCase() == 'save')
		{
			var sending = '`' + wholegeometry.definition + '`' + wholematerial.diffuseColor + '`' + assembleVec3f(wholegeometry.bboxCenter)
			   + '`' + assembleVec3f(wholegeometry.bboxSize) + '`' + assembleFloatArray(wholegeometry.resolution)
			   + '`' + assembleFloatArray(wholegeometry.parameters) + '`' + assembleColorArray(wholematerial.patternColor)
			   + '`' + assembleFloatArray(wholematerial.patternKey) + '`' + wholeshape.polygonizer  + '`' + wholeshape.cycleInterval
			   + '`' + assembleVec2f(wholematerial.timeSpan) + '`' + wholetexture.definition + '`' + assembleVec2f(wholetexture.timeSpan)
			   + '`' + assembleVec2f(wholegeometry.timeSpan) + '`';
			print('-------------Save Start--------------');
			print(sending);
			print('--------------Save End---------------');


//			var saveshape = '';
////			saveshape +='Transform{';
////			saveshape +='translation '+shape.gtranslation;
////			saveshape +='rotation '+shape.grotation;
////			saveshape +='scale '+shape.gscale;
////			saveshape+='children [';
//			saveshape +='FShape {';
//			saveshape +='polygonizer \"' + wholeshape.polygonizer + '\"';
//			saveshape +='	loop ' + (wholeshape.loop ? 'TRUE' : 'FALSE');
//			saveshape +='	cycleInterval ' + wholeshape.cycleInterval;
//			saveshape +='	appearance FAppearance {';
//			saveshape +='		material FMaterial {';
//			saveshape +='			diffuseColor \"' + wholematerial.diffuseColor + '\"';
//			saveshape +='			patternKey ' + wholematerial.patternKey;
//			saveshape +='			patternColor ' + wholematerial.patternColor;
//			saveshape +='			timeSpan ' + wholematerial.timeSpan;
//			saveshape +='		}';
//			saveshape +='		texture3D FTexture3D {';
//			saveshape +='			definition \"' + wholetexture.definition + '\"';
//			saveshape +='			timeSpan ' + wholetexture.timeSpan;
//			saveshape +='         type \"displacement\"';
//			saveshape +='		}';
//			saveshape +='	}';
//			saveshape +='	geometry FGeometry {';
//			saveshape +='		definition \"' + wholegeometry.definition + '\"';
//			saveshape +='		parameters ' + wholegeometry.parameters;
//			saveshape +='		bboxSize ' + wholegeometry.bboxSize;
//			saveshape +='		bboxCenter ' + wholegeometry.bboxCenter;
//			saveshape +='		resolution ' + wholegeometry.resolution;
//			saveshape +='		timeSpan ' + wholegeometry.timeSpan;
//			saveshape +='	}';
//			saveshape +='}';
////			saveshape +='	]';
////			saveshape +='}';


//			var head = '';
//			head += 'EXTERNPROTO FGeometry [';
//			head += 'exposedField SFString definition';
//			head += 'exposedField MFFloat parameters';
//			head += 'exposedField MFInt32 resolution';
//			head += 'exposedField SFVec3f bboxCenter';
//			head += 'exposedField SFVec3f bboxSize';
//			head += 'exposedField SFString type';
//			head += 'exposedField MFNode	parents';
//			head += 'exposedField SFVec2f timeSpan';
//			head += '] \"FVRML.wrl#FGeometry\"';
//			head += 'EXTERNPROTO FMaterial [';
//			head += 'exposedField SFString diffuseColor';
//			head += 'exposedField SFString type';
//			head += 'exposedField MFColor patternColor';
//			head += 'exposedField MFFloat patternKey';
//			head += 'exposedField SFString ambientIntensity';
//			head += 'exposedField SFString emissiveColor';
//			head += 'exposedField SFString shininess';
//			head += 'exposedField SFString specularColor';
//			head += 'exposedField SFString transparency';
//			head += 'exposedField MFFloat parameters';
//			head += 'exposedField MFNode	parents';
//			head += 'exposedField SFVec2f timeSpan';
//			head += '] \"FVRML.wrl#FMaterial\"';
//			head += 'EXTERNPROTO FTexture3D [';
//			head += 'exposedField SFString definition';
//			head += 'exposedField SFString type';
//			head += 'exposedField MFFloat parameters';				
//			head += 'exposedField MFNode	parents';
//			head += 'exposedField SFVec2f timeSpan';
//			head += '] \"FVRML.wrl#FTexture3D\"';
//			head += 'EXTERNPROTO FAppearance [';
//			head += 'exposedField SFNode	material';
//			head += 'exposedField SFNode	texture';
//			head += 'exposedField SFNode	textureTransform';
//			head += 'exposedField SFNode	texture3D';
//			head += 'exposedField MFNode	parents';
//			head += 'eventIn	SFBool refresh';
//			head += '] \"FVRML.wrl#FAppearance\"';
//			head += 'EXTERNPROTO FShape [';
//			head += 'exposedField SFNode	geometry';
//			head += 'exposedField SFNode	appearance';
//			head += 'exposedField SFString polygonizer';
//			head += 'exposedField MFNode	parents';
//			head += 'exposedField SFTime	startTime';
//			head += 'exposedField SFTime stopTime';				
//			head += 'exposedField SFTime cycleInterval';
//			head += 'exposedField SFBool	loop';
//			head += 'exposedField SFBool	enabled';
//			head += 'eventOut SFTime	cycleTime';
//			head += 'eventIn SFFloat set_fraction';
//			head += 'field SFInt32 frames';
//			head += '] \"FVRML.wrl#FShape\"';
//			head += 'EXTERNPROTO FTransform [';
//			head += 'exposedField SFString operation';
//			head += 'exposedField SFString type';
//			head += 'exposedField SFString polygonizer';
//			head += 'exposedField MFFloat parameters';
//			head += 'exposedField SFString center';
//			head += 'exposedField SFString rotation';
//			head += 'exposedField SFString scale';
//			head += 'exposedField SFString scaleOrientation';
//			head += 'exposedField SFString translation';
//			head += 'exposedField MFNode children';				
//			head += 'exposedField MFNode	parents';
//			head += 'eventIn	SFBool refresh';
//			head += 'exposedField SFVec2f timeSpan';
//			head += 'exposedField SFTime	startTime';
//			head += 'exposedField SFTime stopTime';
//			head += 'exposedField SFTime cycleInterval';
//			head += 'exposedField SFBool	loop';
//			head += 'exposedField SFBool	enabled';
//			head += 'eventOut SFTime	cycleTime';
//			head += 'eventIn SFFloat set_fraction';
//			head += 'field SFInt32 frames';			
//			head += '] \"FVRML.wrl#FTransform\"';


////			head += 'NavigationInfo {';
////			head += '	type [\"EXAMINE\",\"ANY\"]';
////			head += '}';	
////			head += 'Viewpoint {';				
////			head += 'fieldOfView 0.7';	
////			head += 'position 0 0 5';	
////			head += 'description \"Overview\"';	
////			head += '	}';					
			

//			var create = '';
//			create = head+saveshape;
			


//			var tempNode = Browser.createVrmlFromString(saveshape);

//			var ret = Browser.saveNode(tempNode,'head','writeProtos=false,writeExternProtos=true,filter=VRML Files|*.wrl||,title=Save Node as...,defaultExt=*.wrl');

			savemodel = !savemodel;
			
		}
		else 
		{
			var str;

				if (str1 == 'reset')
				{
				str1 = 'shape:1-sqrt(x*x+y*y+z*z)#color:r=0.7;g=0.7;b=0.7;#texture:0#parameters:0#resolution:100,100,100#bboxsize:2.5,2.5,2.5 #bboxcenter:0,0,0#patterncolor:#patternkey:#loop:false#polygonizer:analytical#cycleinterval:1#geometrytimespan:0,1#colortimespan:0,1#texturetimespan:0,1';
																													//
				//#--added
				 resetShape();
				 resetTN();
				//#!--end added
			}
			str = split(str1, '#');
			for(var l=0;l<str.length;++l)
			{
				var sstr = str[l];
				if(sstr.toLowerCase().substring(0, 6) == 'shape:')
				{
					if (sstr.indexOf(';') != -1) {
						source = sstr.substring(6);
						geodefSource = sstr.substring(6);
					}
					else {
						source = 'function frep(x1,y1,z1,t){\\nx=x1;y=y1;z=z1;\\nfun=' + sstr.substring(6,sstr.length) + ';\\nreturn fun;}';
						geodefSource = 'fun='+sstr.substring(6)+';';
					}

					
				
				//#--added
				 resetShape();
				//#!--end added
			 }
				else if(sstr.toLowerCase().substring(0, 6) == 'color:')
				{
					if (sstr.indexOf(';') != -1) {
						color = 'function frep(x1,y1,z1,t){\\nu=x1;v=y1;w=z1;\\n' + sstr.substring(6,sstr.length) + '\\nreturn 0;}';
						difcolorSource = sstr.substring(6,sstr.length);
					} else {
						color = 'function frep(x1,y1,z1,t){\\nx=x1;y=y1;z=z1;\\npatternValue(' + sstr.substring(6,sstr.length) + ');\\nreturn 0;}';
						difcolorSource = 'patternValue(' + sstr.substring(6,sstr.length) + ');';
					}

			}
				else if(sstr.toLowerCase().substring(0, 8) == 'texture:')
				{
					textureDef = sstr.substring(8,sstr.length);
					source = wholegeometry.definition;
					geodefSource = shape.geoDef;
				}
				else if(sstr.toLowerCase().substring(0, 11) == 'parameters:')
				{
					var ss = split(sstr.substring(11, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					parameters = dd;
				}
				else if(sstr.toLowerCase().substring(0, 11) == 'resolution:')
				{
					var ss = split(sstr.substring(11, sstr.length),',');
					var dd = new MFInt32();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseInt(ss[i]);
					}
					resolution = dd;
				}
				else if(sstr.toLowerCase().substring(0, 9) == 'bboxsize:')
				{
					bbox = TRUE;
					var ss = split(sstr.substring(9, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 3)
					{
						bboxSize = new SFVec3f(dd[0], dd[1], dd[2]);
					}
					bbox = FALSE;

				}
				else if(sstr.toLowerCase().substring(0, 11) == 'bboxcenter:')
				{
					bbox = TRUE;
					var ss = split(sstr.substring(11, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 3)
					{
						bboxCenter = new SFVec3f(dd[0], dd[1], dd[2]);
					}
					bbox = FALSE;

				}
				else if(sstr.toLowerCase().substring(0, 13) == 'patterncolor:')
				{
					var ss = split(sstr.substring(13, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					var out = new MFColor();
					for(var i=0;i*3+2<dd.length;++i)
					{
						out[i] = new SFColor(dd[i*3], dd[i*3+1], dd[i*3+2]);
					}
					patternColor = out;
				}
				else if(sstr.toLowerCase().substring(0, 11) == 'background:')
				{
					var ss = split(sstr.substring(11, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					var out = new MFColor();
					for(var i=0;i*3+2<dd.length;++i)
					{
						out[i] = new SFColor(dd[i*3], dd[i*3+1], dd[i*3+2]);
					}
					bground = out;
				}
				else if(sstr.toLowerCase().substring(0, 11) == 'patternkey:')
				{
					var ss = split(sstr.substring(11, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					patternKey = dd;
				}
				else if(sstr.toLowerCase().substring(0, 17) == 'geometrytimespan:')
				{
					var ss = split(sstr.substring(17, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 2)
					{
						geometryTimeSpan = new SFVec2f(dd[0], dd[1]);
					}
				}
				else if(sstr.toLowerCase().substring(0, 14) == 'colortimespan:')
				{
					var ss = split(sstr.substring(14, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 2)
					{
						colorTimeSpan = new SFVec2f(dd[0], dd[1]);
					}
				}
				else if(sstr.toLowerCase().substring(0, 16) == 'texturetimespan:')
				{
					var ss = split(sstr.substring(16, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 2)
					{
						textureTimeSpan = new SFVec2f(dd[0], dd[1]);
					}
				}
				else if(sstr.toLowerCase().substring(0, 14) == 'cycleinterval:')
				{
					cycleInterval = parseFloat(sstr.substring(14, sstr.length));
				}
				else if(sstr.toLowerCase().substring(0, 12) == 'polygonizer:')
				{
					polygonizer = sstr.substring(12, sstr.length);
				}
				else if(sstr.toLowerCase().substring(0, 5) == 'loop:')
				{
					loop = (sstr.toLowerCase().indexOf('true') != -1);
				}
				else if(sstr.toLowerCase().substring(0,6) == 'gmove:'){

					var ss = split(sstr.substring(6, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 3)
					{
					//	gmove = new SFVec3f(dd[0]+shape.gtranslation[0] , dd[1]+shape.gtranslation[1], dd[2]+shape.gtranslation[2]);
						gmove = new SFVec3f(dd[0], dd[1], dd[2]);
						print(amove);
					}
				
				}
				else if(sstr.toLowerCase().substring(0,6) == 'amove:'){

					var ss = split(sstr.substring(6, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 3)
					{
						amove = new SFVec3f(dd[0], dd[1], dd[2]);
						print(amove);
					}
				
				}
				else if(sstr.toLowerCase().substring(0,8) == 'grotate:'){

					var ss = split(sstr.substring(8, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 4)
					{
						grot = new SFRotation(dd[0], dd[1], dd[2],dd[3]);
						print(grot);
					}
				
				}
				else if(sstr.toLowerCase().substring(0,8) == 'arotate:'){

					var ss = split(sstr.substring(8, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 4)
					{
						arot = new SFRotation(dd[0], dd[1], dd[2],dd[3]);
						print(arot);
					}
				
				}
					else if(sstr.toLowerCase().substring(0,7) == 'ascale:'){

					var ss = split(sstr.substring(7, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 3)
					{
						ascale = new SFVec3f(dd[0], dd[1], dd[2]);
						print(ascale);
					}
				
				}
					else if(sstr.toLowerCase().substring(0,7) == 'gscale:'){

					var ss = split(sstr.substring(7, sstr.length),',');
					var dd = new MFFloat();
					for(var i=0;i<ss.length;++i)
					{
						dd[i] = parseFloat(ss[i]);
					}
					if(dd.length == 3)
					{
						gscale = new SFVec3f(dd[0], dd[1], dd[2]);
						print(gscale);
					}
				
				}



//								---------force define
//				else if(sstr.toLowerCase().substring(0, 9) == 'friction:')
//				{
//					if (sstr.indexOf(';') == -1) {friction = sstr.substring(9);}
//					else {friction = 'function frep(x1,y1,z1,t){\\nx=x1;y=y1;z=z1;fun=' + sstr.substring(9,sstr.length) + ';\\nreturn fun;}';}
//				friction = sstr.substring(9);
//					if(friction=='0') {boolfriction = false; print('Friction 0'); }
//				    else {boolfriction = true; print('friction enabled:'+friction);}
//				}
//				else if(sstr.toLowerCase().substring(0, 8) == 'tension:')
//				{
//				    if (sstr.indexOf(';') == -1) {tension = sstr.substring(8);}
//					else {tension = 'function frep(x1,y1,z1,t){\\nx=x1;y=y1;z=z1;fun=' + sstr.substring(8,sstr.length) + ';\\nreturn fun;}';}
//				tension = sstr.substring(8);
//					if(tension == '0') {booltension =false; print('Tension 0');}
//					else {booltension= true; print('tension enabled:'+tension);}
//				}
//				else if(sstr.toLowerCase().substring(0, 8) == 'density:')
//				{
//					if (sstr.indexOf(';') == -1) {density = sstr.substring(8);}
//					else {density = 'function frep(x1,y1,z1,t){\\nx=x1;y=y1;z=z1;fun=' + sstr.substring(8,sstr.length) + ';\\nreturn fun;}';}
//				density = sstr.substring(8);
//					if(density=='0') { booldensity=false;print('Density 0');}
//					else {booldensity=true; print('density enabled:'+density);}
//				}
//				else if(sstr.toLowerCase().substring(0, 11) == 'forcefield:')
//				{
//					if (sstr.indexOf(';') == -1) {forcefield = sstr.substring(11);}
//					else {forcefield = 'function frep(x1,y1,z1,t){\\nx=x1;y=y1;z=z1;fun=' + sstr.substring(11,sstr.length) + ';\\nreturn fun;}';}
//				forcefield = sstr.substring(11);
//					if(forcefield=='0') {boolforcefield = false; print('FForce 0');}
//					else { boolforcefield = true; print('forcefield enabled:'+forcefield);}
//				}

				else if(sstr.toLowerCase().substring(0, 4) == 'load'){loadmodel=!loadmodel;}
				//#---added  contains the value chatting to bot
				else{
					ChatToBot = str1.toLowerCase();
					print(ChatToBot);
				}


						  
				//#!---end added

				refreshform = !refreshform;
			}
		}
	}

	//#-- added

function resetShape(){

	resetModellerShape = res;
	if(res==true) res = false;
	else res = true;

//	print('chat resetshape');
	
}

function resetTN(){
	resetToolN = resTN;
	if(resTN==true) resTN = false;
	else res = true;
}

//#!-- end added

    " 
} 

################################
## Add route for chat command ##
####################################################
#ROUTE SharedZone.groupChat TO ChatScript.receiveChat
ROUTE ChatScript.source	TO WholeGeometry.definition
ROUTE ChatScript.geodefSource TO Shape.geoDef

ROUTE ChatScript.color TO Material.diffuseColor
ROUTE ChatScript.difcolorSource	TO Shape.difusecolorDef

#--added

ROUTE ChatScript.source	TO Geometry.definition

ROUTE ChatScript.color TO WholeMaterial.diffuseColor
ROUTE ChatScript.patternColor TO WholeMaterial.patternColor
ROUTE ChatScript.patternKey	TO WholeMaterial.patternKey
ROUTE ChatScript.colorTimeSpan TO WholeMaterial.timeSpan

ROUTE ChatScript.polygonizer TO	WholeShape.polygonizer
ROUTE ChatScript.cycleInterval TO WholeShape.cycleInterval
ROUTE ChatScript.loop TO WholeShape.loop

ROUTE ChatScript.textureDef TO	WholeTexture.definition
ROUTE ChatScript.textureTimeSpan TO WholeTexture.timeSpan

ROUTE ChatScript.resetModellerShape	TO Modeller.resetCoord
ROUTE ChatScript.resetToolN	TO Modeller.resetToolN

ROUTE ChatScript.gmove TO Shape.gtranslation
ROUTE ChatScript.grot TO Shape.grotation
ROUTE ChatScript.gscale	TO Shape.gscale
ROUTE ChatScript.amove TO Shape.atranslation
ROUTE ChatScript.arot TO Shape.arotation
ROUTE ChatScript.ascale	TO Shape.ascale
ROUTE ChatScript.gmove TO WholeShapeTransform.translation
ROUTE ChatScript.grot TO WholeShapeTransform.rotation
ROUTE ChatScript.gscale	TO WholeShapeTransform.scale

#--added for sample tool
#ROUTE ChatScript.color TO SampleMaterial.diffuseColor
#ROUTE ChatScript.patternColor TO SampleMaterial.patternColor
#ROUTE ChatScript.patternKey	TO SampleMaterial.patternKey
#ROUTE ChatScript.colorTimeSpan TO SampleMaterial.timeSpan
#!--end added for ample tool

#!--end added

#--added


#!--end added

ROUTE ChatScript.bground TO background.skyColor
ROUTE ChatScript.parameters	TO WholeGeometry.parameters

ROUTE ChatScript.bboxCenter	TO WholeGeometry.bboxCenter
ROUTE ChatScript.bboxCenter	TO ToolGeometry.bboxCenter


ROUTE ChatScript.bboxSize TO WholeGeometry.bboxSize
ROUTE ChatScript.bboxSize TO ToolGeometry.bboxSize

ROUTE ChatScript.resolution	TO WholeGeometry.resolution
ROUTE ChatScript.resolution	TO ToolGeometry.resolution
ROUTE ChatScript.patternColor TO Material.patternColor
ROUTE ChatScript.patternKey	TO Material.patternKey
ROUTE ChatScript.polygonizer TO	Shape.polygonizer
ROUTE ChatScript.textureDef TO	Texture.definition
ROUTE ChatScript.cycleInterval TO Shape.cycleInterval
ROUTE ChatScript.geometryTimeSpan TO WholeGeometry.timeSpan
ROUTE ChatScript.colorTimeSpan TO Material.timeSpan
ROUTE ChatScript.textureTimeSpan TO Texture.timeSpan
ROUTE ChatScript.loop TO Shape.loop
ROUTE ChatScript.bbox TO Modeller.boundingBox1

ROUTE ChatScript.refreshform TO	Modeller.refreshfromchat
ROUTE ChatScript.loadmodel TO Modeller.loadmodel

ROUTE Modeller.receiveChat TO ChatScript.receiveChat

ROUTE ChatScript.savemodel TO Modeller.savemodel
ROUTE ChatScript.exportwrl TO Modeller.exportwrl


ROUTE WholeGeometry.bboxCenter TO Modeller.bbox2
ROUTE WholeGeometry.bboxSize TO	Modeller.bbox2
#--added for force
#ROUTE ChatScript.friction TO Friction.definition
#ROUTE ChatScript.tension TO	Tension.definition
#ROUTE ChatScript.density TO	Density.definition
#ROUTE ChatScript.forcefield	TO Forcefield.definition
#ROUTE ChatScript.friction TO toolFriction.definition
#ROUTE ChatScript.tension TO	toolTension.definition
#ROUTE ChatScript.density TO	toolDensity.definition
#ROUTE ChatScript.forcefield	TO toolForcefield.definition
#ROUTE ChatScript.booldensity TO	Density.enable
#ROUTE ChatScript.boolforcefield	TO Forcefield.enable
#ROUTE ChatScript.boolfriction TO Friction.enable
#ROUTE ChatScript.booltension TO	Tension.enable
#ROUTE ChatScript.booldensity TO	toolDensity.enable
#ROUTE ChatScript.boolforcefield	TO toolForcefield.enable
#ROUTE ChatScript.boolfriction TO toolFriction.enable
#ROUTE ChatScript.booltension TO	toolTension.enable
#!--end added for force



#################################################
# Adding chat:

EXTERNPROTO Chat
[
    exposedField SFFloat   height         # 3
    exposedField SFFloat   width          # 10
    eventOut     SFString  meSay

	eventOut SFBool	keyflag				#false
		
    eventIn      MFString    hasSaid
    eventIn      SFBool    focus          # enables text input if true.
    eventIn      SFTime    startAnimation
    field        SFBool    initiallyShown # TRUE
]
  "Chat.wrl#Chat"


#DEF Chat Chat
#{
#}

#ROUTE Chat.meSay TO	ChatScript.receiveChat
#ROUTE Chat.keyflag TO Modeller.keyflag

#end of chat
################################################
